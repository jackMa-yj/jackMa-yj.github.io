<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>&#39;Face_warp&#39;</title>
      <link href="/2024/10/28/Face-warp/"/>
      <url>/2024/10/28/Face-warp/</url>
      
        <content type="html"><![CDATA[<p>我们来逐个回答这些问题，便于你理解：</p><h3 id="2-static-和-const"><a href="#2-static-和-const" class="headerlink" title="2. static 和 const"></a>2. <code>static</code> 和 <code>const</code></h3><ul><li><p>**<code>static</code>**：在C++中，<code>static</code>关键字可以有不同的含义：</p><ul><li><strong>在函数内部</strong>：用于声明静态变量，使其在函数调用结束后依旧保留状态。</li><li><strong>在类中</strong>：用于声明类的静态成员变量或静态成员函数。静态成员属于类而非对象，所有对象共享。</li><li><strong>在文件作用域</strong>：将函数或变量声明为静态可以限制其作用域，只在当前文件中可见。</li></ul></li><li><p>**<code>const</code>**：<code>const</code>关键字用于定义常量或不可修改的变量。<code>const</code>修饰的变量必须在声明时初始化，且不可更改。常见的用法包括：</p><ul><li>修饰指针，使指针内容不可更改或指针本身不可更改（<code>const int* p</code>与<code>int* const p</code>）。</li><li>修饰类成员函数，使其不可修改类成员数据，适用于只读访问。</li></ul></li></ul><h3 id="3-指针数组-和-数组指针"><a href="#3-指针数组-和-数组指针" class="headerlink" title="3. 指针数组 和 数组指针"></a>3. 指针数组 和 数组指针</h3><ul><li><strong>指针数组</strong>：即存储指针的数组，数组的每个元素都是指向某种数据类型的指针。例如，<code>int* arr[10]</code>是一个指针数组，包含10个指向<code>int</code>的指针。</li><li><strong>数组指针</strong>：即指向数组的指针，指针指向一个数组的起始地址。例如，<code>int (*p)[10]</code>是一个数组指针，指向一个包含10个<code>int</code>元素的数组。</li></ul><h3 id="4-线程池（使用时的注意事项）"><a href="#4-线程池（使用时的注意事项）" class="headerlink" title="4. 线程池（使用时的注意事项）"></a>4. 线程池（使用时的注意事项）</h3><p>线程池用于管理多个线程的创建和销毁，避免线程频繁创建带来的开销。使用线程池时需要注意：</p><ul><li><strong>任务划分</strong>：确保任务独立、无依赖，避免线程竞争。</li><li><strong>线程数量</strong>：根据CPU核心数和任务类型决定线程池大小，避免创建过多线程。</li><li><strong>异常处理</strong>：确保线程中的异常被捕获，否则会导致线程崩溃或未完成任务。</li><li><strong>资源回收</strong>：线程池应具备合理的线程回收机制，避免资源泄漏。</li></ul><h3 id="5-TCP-和-UDP-的区别"><a href="#5-TCP-和-UDP-的区别" class="headerlink" title="5. TCP 和 UDP 的区别"></a>5. TCP 和 UDP 的区别</h3><ul><li><strong>TCP</strong>（Transmission Control Protocol）：一种面向连接的可靠传输协议，数据传输之前需要建立连接，保证数据的有序和准确到达。</li><li><strong>UDP</strong>（User Datagram Protocol）：一种无连接的传输协议，不保证数据到达顺序和准确性，传输速度较快，适合实时应用如视频流和游戏。</li></ul><h3 id="6-TCP-三次握手-（服务器端-SYN-ACK-丢失处理）"><a href="#6-TCP-三次握手-（服务器端-SYN-ACK-丢失处理）" class="headerlink" title="6. TCP 三次握手 （服务器端 SYN.ACK 丢失处理）"></a>6. TCP 三次握手 （服务器端 SYN.ACK 丢失处理）</h3><p>TCP三次握手：</p><ol><li><strong>客户端</strong>发送SYN包请求连接。</li><li><strong>服务器端</strong>收到后返回SYN.ACK确认连接。</li><li><strong>客户端</strong>再发送ACK确认包，连接建立。</li></ol><p>若服务器端的SYN.ACK丢失，客户端会因等待超时重新发送SYN，触发服务器端重新回复SYN.ACK。</p><h3 id="7-TCP-如何保证数据传输的准确性，机制有哪些"><a href="#7-TCP-如何保证数据传输的准确性，机制有哪些" class="headerlink" title="7. TCP 如何保证数据传输的准确性，机制有哪些"></a>7. TCP 如何保证数据传输的准确性，机制有哪些</h3><p>TCP提供可靠传输的机制包括：</p><ul><li><strong>序列号</strong>：每个包都有唯一序号，接收方可以按序组装数据并检测丢失。</li><li><strong>确认应答</strong>：接收方需确认收到数据包，未确认的数据包会重发。</li><li><strong>流量控制</strong>：接收方可以通知发送方其接收能力，避免发送过多数据。</li><li><strong>拥塞控制</strong>：通过调整发送速度，避免网络拥堵。</li><li><strong>检验和</strong>：每个数据包有校验码，用于检测传输中的数据损坏。</li></ul><h3 id="8-如何理解-TCP-是面向连接的基于字节流的协议，UDP-是面向无连接的基于数据报的协议"><a href="#8-如何理解-TCP-是面向连接的基于字节流的协议，UDP-是面向无连接的基于数据报的协议" class="headerlink" title="8. 如何理解 TCP 是面向连接的基于字节流的协议，UDP 是面向无连接的基于数据报的协议"></a>8. 如何理解 TCP 是面向连接的基于字节流的协议，UDP 是面向无连接的基于数据报的协议</h3><ul><li><strong>TCP</strong>：面向连接的字节流协议，即数据在连接建立后以字节流形式连续传输。TCP需建立连接（如三次握手），适合顺序性和准确性要求高的传输。</li><li><strong>UDP</strong>：无连接的数据报协议，每个数据包独立传输，不依赖先前包。无需建立连接，适合实时性要求高的应用。</li></ul><h3 id="9-IPC（进程间通信）"><a href="#9-IPC（进程间通信）" class="headerlink" title="9. IPC（进程间通信）"></a>9. IPC（进程间通信）</h3><p>IPC指多个进程之间数据交换和通信的方法，常见的IPC机制包括：</p><ul><li><strong>管道</strong>和<strong>有名管道</strong>：用于单向或双向进程间数据传输。</li><li><strong>信号量</strong>：用于进程间同步和资源控制。</li><li><strong>共享内存</strong>：多个进程直接访问内存区域，速度快。</li><li><strong>消息队列</strong>：进程通过消息发送接收数据。</li><li><strong>套接字</strong>：通过网络实现本地或分布式进程通信。</li></ul><h3 id="10-有名管道（FIFO）的缺点"><a href="#10-有名管道（FIFO）的缺点" class="headerlink" title="10. 有名管道（FIFO）的缺点"></a>10. 有名管道（FIFO）的缺点</h3><p>有名管道的缺点主要有：</p><ul><li><strong>只能在同一主机</strong>上通信，不能跨主机。</li><li><strong>半双工通信</strong>：数据只能单向传输，需建立两个管道实现双向通信。</li><li><strong>阻塞读写</strong>：读进程或写进程可能会因为另一方未准备好而阻塞。</li></ul><h3 id="12-Shell-的-for-循环"><a href="#12-Shell-的-for-循环" class="headerlink" title="12. Shell 的 for 循环"></a>12. Shell 的 for 循环</h3><p>Shell的<code>for</code>循环用于遍历列表中的每个元素：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for var in item1 item2 item3</span><br><span class="line">do</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">执行的命令</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>或用于遍历文件、命令输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for var in $(ls)</span><br><span class="line">do</span><br><span class="line">  echo &quot;$var&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="C和C-的区别"><a href="#C和C-的区别" class="headerlink" title="C和C++的区别"></a>C和C++的区别</h3><ol><li>C面向对象C++面向过程</li><li>C++具有封装、继承、多态的性质    </li><li>C++具有STL</li></ol><h3 id="define和const的区别"><a href="#define和const的区别" class="headerlink" title="#define和const的区别"></a>#define和const的区别</h3><ol><li>一个发生在预处理阶段，一个发生在编译阶段</li><li>#define只是简单的字符串替换没有进行类型的安全检查，const进行类型的安全检查</li><li>#define的字符串会替换多份，更占用内存，const常量只保存一份（保存在常量区）</li></ol><h3 id="程序编译的过程"><a href="#程序编译的过程" class="headerlink" title="程序编译的过程"></a>程序编译的过程</h3><p>预处理：头文件展开，宏替换，条件编译，去注释<br>编译：语义分析，语法分析，目标代码生成，优化，生成汇编代码<br>汇编：生成二进制文件<br>链接：将目标文件进行链接形成可执行程序（解决符号表的问题）</p><h3 id="内存的布局"><a href="#内存的布局" class="headerlink" title="内存的布局"></a>内存的布局</h3><p>从高地址到低地址（自顶向下），栈区，共享区，堆区，代码段，数据段</p><img src="/2024/10/28/Face-warp/f5008a21422819f3b6c4027d3960d6db.png" class=""><h3 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h3><p>管道，消息队列，共享内存，信号量，Socket网络通信</p><h3 id="TCP拥塞控制机制"><a href="#TCP拥塞控制机制" class="headerlink" title="TCP拥塞控制机制"></a>TCP拥塞控制机制</h3><ol><li>慢启动 因为TCP链接刚建立之后不确定网络的负荷情况，因此，较好的方式就是先探测一下，即由小到大逐渐增大发送窗口，<br>通常在刚开始发送报文的时候，先把拥塞窗口的大小设置为一个最大报文段MSS的数值，而在每收到一个对新的报文的确认后，<br>就把拥塞窗口增加至多一个MSS的数值。（注意：因为是每一个ACK都会让MSS加1，所以cwnd &#x3D; cwnd*2）<br>为了防止拥塞窗口的cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量，当cwnd &gt;&#x3D; ssthresh的时候，就会进入“拥塞避免算法”</li><li>拥塞避免 避免增长过快导致网络拥塞，让拥塞窗口cwnd缓慢的增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd整体加上1，而不是加倍。<br>注意:无论是在满开始阶段还是拥塞避免阶段，只要发送方没有接收到确认信息，那么就是出现了网络拥塞，<br>则需要将慢开始门限设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口的大小重新设置为1，执行慢开始算法。</li><li>快重传 发送方连续收到三次重复的确认就应当立即重传对方尚未收到的报文</li><li>快恢复 当发送方连续收到三个重复的确认，把慢开始门限设置为此时拥塞窗口值的一半<br>由于发送方现在认为网络很可能没有发生拥塞，则此时不执行慢开始算法，而是将cwnd的大小设置为减半后的慢开始门限sstream的数值，开始执行拥塞避免算法。</li></ol><h3 id="面向对象和面向过程的思想有什么区别"><a href="#面向对象和面向过程的思想有什么区别" class="headerlink" title="面向对象和面向过程的思想有什么区别"></a>面向对象和面向过程的思想有什么区别</h3><ol><li>设计思想 面向过程：以过程（步骤）为核心，将整个程序逻辑按功能划分成一系列函数;面向对象：以对象和类为核心，将数据和行为封装到对象中，并通过对象的相互作用实现功能</li><li>代码组织结构 面向过程：数据和操作是分开的;面向对象：数据和操作封装在对象中，类是对象的模板 </li><li>重用性与维护性 面向过程：POP主要通过函数的重用来实现代码重用;面向对象：OOP的类和对象封装实现了更高的代码复用性</li></ol><h3 id="进程的几大状态"><a href="#进程的几大状态" class="headerlink" title="进程的几大状态"></a>进程的几大状态</h3><p>进程在操作系统中通常会经历几种基本状态，每种状态代表了进程当前的活动情况。常见的进程状态主要有以下几种：</p><ol><li><p><strong>新建（New）</strong><br>进程刚被创建，还未被系统调度到执行的状态。</p></li><li><p><strong>就绪（Ready）</strong><br>进程已准备好执行，但由于没有空闲的CPU，暂时等待被调度器分配资源。此状态的进程具备执行条件，只需等待分配CPU即可运行。</p></li><li><p><strong>运行（Running）</strong><br>进程获得了CPU资源，正在执行状态。单核处理器上通常只有一个进程处于“运行”状态，而多核处理器上可以同时运行多个进程。</p></li><li><p><strong>阻塞（Blocked）&#x2F;等待（Waiting）</strong><br>进程正在等待某种事件的完成（如I&#x2F;O操作、获取锁等），暂时无法继续执行。当所等待的事件发生时，进程会从阻塞状态转为就绪状态。</p></li><li><p><strong>终止（Terminated）&#x2F;退出（Exit）</strong><br>进程执行完毕，或由于错误而被强制结束，此时进程处于“终止”状态。系统会回收资源，等待其他进程来使用。</p></li><li><p><strong>挂起（Suspended）</strong><br>某些操作系统中还存在“挂起”状态，分为<strong>就绪挂起</strong>和<strong>阻塞挂起</strong>。挂起状态下的进程被暂时移出主存，以便腾出更多内存资源，但挂起进程仍保留运行信息，以备恢复。</p></li></ol><h3 id="状态切换"><a href="#状态切换" class="headerlink" title="状态切换"></a>状态切换</h3><p>进程在运行过程中会在上述几种状态之间进行转换。例如：</p><ul><li><strong>就绪 → 运行</strong>：当进程被调度到CPU时。</li><li><strong>运行 → 阻塞</strong>：进程需要等待I&#x2F;O操作完成时。</li><li><strong>阻塞 → 就绪</strong>：等待事件完成时，进程重新进入就绪状态。</li><li><strong>运行 → 就绪</strong>：当进程被剥夺CPU资源（例如时间片耗尽）时。</li></ul><h3 id="客户端发送-FIN-后是否能继续发送数据"><a href="#客户端发送-FIN-后是否能继续发送数据" class="headerlink" title="客户端发送 FIN 后是否能继续发送数据"></a>客户端发送 FIN 后是否能继续发送数据</h3><p>客户端发送FIN信号后，表示请求终止连接。此时，连接进入半关闭状态，服务器仍可以向客户端发送数据，<br>但客户端已无法继续发送新数据，只能接收服务器发送的数据。双方均发送FIN信号后，连接完全关闭。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>测试</title>
      <link href="/2024/10/27/Test/"/>
      <url>/2024/10/27/Test/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是测试用例？"><a href="#什么是测试用例？" class="headerlink" title="什么是测试用例？"></a>什么是测试用例？</h3><ul><li>标题</li><li>测试环境</li><li>测试数据</li><li>测试步骤</li><li>期望结果</li></ul><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.student_name</span><br><span class="line"><span class="keyword">FROM</span> students s</span><br><span class="line"><span class="keyword">JOIN</span> courses c <span class="keyword">ON</span> s.course_id <span class="operator">=</span> c.course_id</span><br><span class="line"><span class="keyword">WHERE</span> c.course_name <span class="operator">=</span> <span class="string">&#x27;数学&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="多表修改"><a href="#多表修改" class="headerlink" title="多表修改"></a>多表修改</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> students</span><br><span class="line"><span class="keyword">JOIN</span> courses <span class="keyword">ON</span> students.course_id <span class="operator">=</span> courses.course_id</span><br><span class="line"><span class="keyword">SET</span> students.course_id <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">WHERE</span> courses.course_name <span class="operator">=</span> <span class="string">&#x27;数学&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="多表删除"><a href="#多表删除" class="headerlink" title="多表删除"></a>多表删除</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> s</span><br><span class="line"><span class="keyword">FROM</span> students s</span><br><span class="line"><span class="keyword">JOIN</span> courses c <span class="keyword">ON</span> s.course_id <span class="operator">=</span> c.course_id</span><br><span class="line"><span class="keyword">WHERE</span> c.course_name <span class="operator">=</span> <span class="string">&#x27;数学&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="冒烟测试"><a href="#冒烟测试" class="headerlink" title="冒烟测试"></a>冒烟测试</h3><p>主要作用是对新版本的软件进行快速初步验证，以确保系统的基本功能正常，适合进一步深入测试。<br>代码评审是检查源代码是否达到模块设计的要求。</p><h3 id="性能测试（Performance-Testing）"><a href="#性能测试（Performance-Testing）" class="headerlink" title="性能测试（Performance Testing）"></a>性能测试（Performance Testing）</h3><p>通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。</p><h3 id="负载测试（Load-Testing）"><a href="#负载测试（Load-Testing）" class="headerlink" title="负载测试（Load Testing）"></a>负载测试（Load Testing）</h3><p>模拟实际软件所承受的负载条件的系统负荷，通过不断加载（如逐渐增加模拟用户的数量）或其他加载方式来观察不同负载下系统的响应时间和数据吞吐量、系统占用的资源（CPU、内存等），以检验系统的行为和特性，以发现系统可能存在的性能瓶颈，内存泄漏，不能实时同步等问题，负载测试更多的体现了一种方法或一种技术。</p><h3 id="压力测试（stress-testing）"><a href="#压力测试（stress-testing）" class="headerlink" title="压力测试（stress testing）"></a>压力测试（stress testing）</h3><p>在强负载（大数据量、大量并发用户等）下的测试，查看应用系统在峰值使用情况下的操作行为，从而有效地发现系统的某项功能隐患，系统是否具有良好的容错能力和可恢复能力。</p><h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><ul><li>语句覆盖</li><li>判定覆盖</li><li>条件覆盖</li><li>判定&#x2F;条件覆盖</li><li>条件组合覆盖</li><li>路径覆盖。</li></ul><h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><ul><li>等价类边界值</li><li>判定表法</li><li>正交法</li><li>场景法</li><li>错误猜测法</li></ul><h3 id="软件验收测试"><a href="#软件验收测试" class="headerlink" title="软件验收测试"></a>软件验收测试</h3><p>按照开发阶段划分，测试过程可以分为以下三个主要阶段:<br>单元测试:这是对软件的最小可测试单元进行测试通常由开发人员在开发过程中进行，目的是验证代码的正确性和功能的正确性。<br>集成测试:在各个模块集成之后进行，目的是检测模块之间的接口和交互是否正确。<br>系统测试:对整个系统进行全面测试，确保所有模块和功能在集成后能够正常工作。</p><p>按照软件测试阶段划分，可以分为以下几种测试：<br>Alpha测试:在开发环境或类似环境下进行的内部测试，通常由开发团队进行，目的是发现并修复软件中的缺陷。<br>Beta测试:在真实环境下进行的外部测试，由用户或第三方进行，目的是获取用户反馈和发现潜在问题。<br>验收测试:由客户或最终用户进行，以确认软件是否满足需求和要求。<br>冒烟测试:在每次构建后进行的快速测试，目的是快速验证软件的基本功能是否正常，确保没有重大问题。</p><p>对面向过程的系统采用的集成策略有：自顶向下，自底向上</p><p>为了提高测试效率，最佳的选择是：选择发现错误可能性大的数据作为测试数据。</p><p>软件测试中的二八原则暗示着测试发现的错误中的80%很可能起源于程序模块的20%。</p><p>错误猜测法基于这样一种假设，以前犯过的错误，以后同样会犯，我犯过的错误别人同样会犯，前人犯过的错误，后人同样会犯。</p><p>测试人员要坚持原则，缺陷未修复完坚决不予通过。</p><p>验收测试一般由客户或最终用户参与，有时会委托给测试团队协助，目的是验证系统是否符合用户需求和合同要求。</p>]]></content>
      
      
      <categories>
          
          <category> wildcard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Graph-Theory</title>
      <link href="/2024/09/22/Graph-Theory/"/>
      <url>/2024/09/22/Graph-Theory/</url>
      
        <content type="html"><![CDATA[<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>本质是二维数组来表示图结构<br>邻接矩阵是从节点的角度来表示图，有多少节点就申请多大的二维数组</p><img src="/2024/09/22/Graph-Theory/20240922213308.png" class=""><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>数组 + 链表的方式来表示<br>邻接表是从边的数量来表示图，有多少边才会申请对应大小的链表</p><img src="/2024/09/22/Graph-Theory/20240922213844.png" class=""><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>深搜三部曲</p><ol><li>确认递归函数，参数</li><li>确认终止条件</li><li>处理目前搜索节点出发的路径</li></ol><h3 id="所有可能的路径"><a href="#所有可能的路径" class="headerlink" title="所有可能的路径"></a><a href="https://leetcode.cn/problems/all-paths-from-source-to-target/description/">所有可能的路径</a></h3><p>给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序）</p><p>graph[i] 是一个从节点 i 可以访问的所有节点的列表（即从节点 i 到节点 graph[i][j]存在一条有向边）。</p><img src="/2024/09/22/Graph-Theory/all_1.jpg" class=""><p>输入：graph &#x3D; [[1,2],[3],[3],[]]<br>输出：[[0,1,3],[0,2,3]]<br>解释：有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3</p><p>题目中暗含了邻接表的结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">allPathsSourceTarget</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph) &#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(<span class="number">0</span>);<span class="comment">//第一个点一定是0</span></span><br><span class="line">        <span class="built_in">dfs</span>(graph,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos==graph.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;graph[pos].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(graph[pos][i]);<span class="comment">//加入邻接表中连接的点</span></span><br><span class="line">            <span class="built_in">dfs</span>(graph,graph[pos][i]);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>一般采取队列作为容器进行遍历</p><h3 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a><a href="https://leetcode.cn/problems/number-of-islands/">岛屿数量</a></h3><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>实例</p><p>输入：grid &#x3D; [<br>[“1”,”1”,”1”,”1”,”0”],<br>[“1”,”1”,”0”,”1”,”0”],<br>[“1”,”1”,”0”,”0”,”0”],<br>[“0”,”0”,”0”,”0”,”0”]<br>]<br>输出：1</p><p>深度搜索优先</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        m=grid.<span class="built_in">size</span>(),n=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(m,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n,<span class="literal">false</span>));</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited[i][j]&amp;&amp;grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid,visited,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid,vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited,<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        visited[i][j]=<span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">            <span class="type">int</span> x=i+dx[k];</span><br><span class="line">            <span class="type">int</span> y=j+dy[k];</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;m&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;n&amp;&amp;!visited[x][y]&amp;&amp;grid[x][y]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(grid,visited,x,y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>广度优先搜索</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="built_in">bfs</span>(grid, visited, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> i,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> cur=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> x=cur.first,y=cur.second;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">                <span class="type">int</span> newX=x+dx[k];</span><br><span class="line">                <span class="type">int</span> newY=y+dy[k];</span><br><span class="line">                <span class="keyword">if</span>(newX&gt;=<span class="number">0</span>&amp;&amp;newX&lt;m&amp;&amp;newY&gt;=<span class="number">0</span>&amp;&amp;newY&lt;n&amp;&amp;!visited[newX][newY]&amp;&amp;grid[newX][newY]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;newX,newY&#125;);</span><br><span class="line">                    visited[newX][newY]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>并查集主要有两个功能:</p><ol><li>将两个元素添加到一个集合中</li><li>判断两个元素在不在同一个集合</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : father[u] = <span class="built_in">find</span>(father[u]); <span class="comment">// 路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> wildcard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/2024/09/10/Binary-tree/"/>
      <url>/2024/09/10/Binary-tree/</url>
      
        <content type="html"><![CDATA[<p>二叉树路径的问题大致可以分为两类：<br>1、自顶向下：<br>顾名思义，就是从某一个节点(不一定是根节点)，从上向下寻找路径，到某一个节点(不一定是叶节点)结束</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">一般路径：</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;res;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode*root,vector&lt;<span class="type">int</span>&gt;path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;  <span class="comment">//根节点为空直接返回</span></span><br><span class="line">    path.<span class="built_in">push_back</span>(root-&gt;val);  <span class="comment">//作出选择</span></span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) <span class="comment">//如果到叶节点  </span></span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left,path);  <span class="comment">//继续递归</span></span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;right,path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># **给定和的路径：**</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode*root, <span class="type">int</span> sum, vector&lt;<span class="type">int</span>&gt; path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    sum -= root-&gt;val;</span><br><span class="line">    path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left, sum, path);</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;right, sum, path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、非自顶向下：<br>就是从任意节点到任意节点的路径，不需要自顶向下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxPath</span><span class="params">(TreeNode *root)</span> <span class="comment">//以root为路径起始点的最长路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left=<span class="built_in">maxPath</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> right=<span class="built_in">maxPath</span>(root-&gt;right);</span><br><span class="line">    res = <span class="built_in">max</span>(res, left + right + root-&gt;val); <span class="comment">//更新全局变量  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left, right);   <span class="comment">//返回左右路径较长者</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">5.使用SQL语句 ALTER TABLE 修改 curriculum 表的“课程名称”列,使之为空。</span><br><span class="line">6.使用SQL语句 ALTER TABLE修改grade 表的“分数”列,使其数据类型为decimal(5,2)。</span><br><span class="line">7.使用SQL语句 ALTER TABLE为 student_info 表添加一个名为“备注”的数据列,其数据类型为VARCHAR(50)。</span><br><span class="line">8.使用SQL语句创建数据库studb,并在此数据库下创建表stu,该表的结构与数据和studentdb数据库中的 student_info 表相同。</span><br><span class="line">6</span><br><span class="line">9.使用SQL语句删除stu表中学号为0004的记录。</span><br><span class="line">10.使用SQL语句更新stud表中学号为0002的家庭住址为“滨江市新建路96号”</span><br><span class="line">妻啭イ</span><br><span class="line">11.删除 stud表的“备注”列。</span><br><span class="line">12.删除 stud 表。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO stu (学号, 姓名, 性别, 出生日期, 家庭住址) VALUES</span><br><span class="line">(&#x27;0001&#x27;, &#x27;张青平&#x27;, &#x27;男&#x27;, &#x27;2000-10-01&#x27;, &#x27;衡阳市桃风路77号&#x27;),</span><br><span class="line">(&#x27;0002&#x27;, &#x27;刘东阳&#x27;, &#x27;男&#x27;, &#x27;1998-12-09&#x27;, &#x27;东阳市八一北路33号&#x27;),</span><br><span class="line">(&#x27;0003&#x27;, &#x27;马晓夏&#x27;, &#x27;女&#x27;, &#x27;1995-05-12&#x27;, &#x27;长岭县五一路763号&#x27;),</span><br><span class="line">(&#x27;0004&#x27;, &#x27;钱忠理&#x27;, &#x27;男&#x27;, &#x27;1994-09-23&#x27;, &#x27;滨海市洞庭大道279号&#x27;),</span><br><span class="line">(&#x27;0005&#x27;, &#x27;孙海洋&#x27;, &#x27;男&#x27;, &#x27;1995-04-03&#x27;, &#x27;长岛县解放路27号&#x27;),</span><br><span class="line">(&#x27;0006&#x27;, &#x27;魏小斌&#x27;, &#x27;男&#x27;, &#x27;1997-11-10&#x27;, &#x27;南京市红旗路113号&#x27;),</span><br><span class="line">(&#x27;0007&#x27;, &#x27;肖月珍&#x27;, &#x27;女&#x27;, &#x27;1997-12-07&#x27;, &#x27;东方南京路11号&#x27;),</span><br><span class="line">(&#x27;0008&#x27;, &#x27;张玲珑&#x27;, &#x27;女&#x27;, &#x27;1997-12-24&#x27;, &#x27;滨江市新建路97号&#x27;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> wildcard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP</title>
      <link href="/2024/09/02/KMP/"/>
      <url>/2024/09/02/KMP/</url>
      
        <content type="html"><![CDATA[<p>KMP主要应用在字符串匹配上。</p><p>KMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</p><img src="/2024/09/02/KMP/kmp.gif" class=""><p>前缀表用来记录 字符串中相同的前缀与后缀字母的个数</p><p>NEXT前缀表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123; <span class="comment">// j要保证大于0，因为下面有取j-1作为数组下标的操作</span></span><br><span class="line">            j = next[j - <span class="number">1</span>]; <span class="comment">// 注意这里，是要找前一位的对应的回退位置了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找出字符串中第一个匹配项的下标"><a href="#找出字符串中第一个匹配项的下标" class="headerlink" title="找出字符串中第一个匹配项的下标"></a><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">找出字符串中第一个匹配项的下标</a></h3><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。<br>如果 needle 不是 haystack 的一部分，则返回  -1 。</p><p>使用KMP</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(needle.size())</span></span>;</span><br><span class="line">        <span class="built_in">getNext</span>(&amp;next[<span class="number">0</span>], needle);</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == needle.<span class="built_in">size</span>() ) &#123;</span><br><span class="line">                <span class="keyword">return</span> (i - needle.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> wildcard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2024/08/31/And-check-the-collection/"/>
      <url>/2024/08/31/And-check-the-collection/</url>
      
        <content type="html"><![CDATA[<p>并查集（Union-Find）是一种树形的数据结构，用于处理不相交集合（也称为离散集合）的合并和查询问题。它主要用于动态连通性问题，即确定元素是否属于同一个集合。并查集的两个主要操作是“合并”（Union）和“查找”（Find），所以得名“并查集”。</p><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ul><li><strong>集合（Set）</strong>：一组不相交的元素，也就是说，每个集合中的元素都是唯一的，集合之间没有交集。</li><li><strong>合并（Union）</strong>：将两个不同的集合合并成一个集合。</li><li><strong>查找（Find）</strong>：找到一个元素所在集合的代表元素（根节点），通常用于判断两个元素是否在同一个集合中。</li></ul><h3 id="2-树形表示"><a href="#2-树形表示" class="headerlink" title="2. 树形表示"></a>2. 树形表示</h3><p>在并查集中，每个集合可以用一棵树来表示，树的根节点代表整个集合。集合中的每个元素都是树中的一个节点，且每个节点都有一个指向其父节点的指针。</p><ul><li><strong>根节点（Root）</strong>：一个集合的代表元素，它是树的根。查找操作的结果就是某个元素的根节点。</li><li><strong>路径压缩（Path Compression）</strong>：在查找操作中，通过将树上的所有节点直接连接到根节点来扁平化树结构，从而加速后续的查找操作。</li></ul><h3 id="3-并查集的操作"><a href="#3-并查集的操作" class="headerlink" title="3. 并查集的操作"></a>3. 并查集的操作</h3><h4 id="查找（Find）"><a href="#查找（Find）" class="headerlink" title="查找（Find）"></a>查找（Find）</h4><p>找到元素所在集合的根节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] != x) &#123;</span><br><span class="line">        fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="合并（Union）"><a href="#合并（Union）" class="headerlink" title="合并（Union）"></a>合并（Union）</h4><p>将两个集合合并为一个集合，通常使用按秩合并（Union by Rank）或按大小合并（Union by Size）来优化合并操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rootX = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="type">int</span> rootY = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rank[rootX] &gt; rank[rootY]) &#123;</span><br><span class="line">            fa[rootY] = rootX;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootX] &lt; rank[rootY]) &#123;</span><br><span class="line">            fa[rootX] = rootY;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fa[rootY] = rootX;</span><br><span class="line">            rank[rootX] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-并查集的优化"><a href="#4-并查集的优化" class="headerlink" title="4. 并查集的优化"></a>4. 并查集的优化</h3><ol><li><strong>路径压缩（Path Compression）</strong>：在查找时将树“扁平化”，使得树的高度变小，从而加速后续查找操作。</li><li><strong>按秩合并（Union by Rank）</strong>：总是将秩（即树的高度）较小的树合并到秩较大的树上，以保持树的高度尽量小。</li><li><strong>按大小合并（Union by Size）</strong>：总是将节点数量较少的树合并到节点数量较多的树上。</li></ol><h3 id="5-使用场景"><a href="#5-使用场景" class="headerlink" title="5. 使用场景"></a>5. 使用场景</h3><p>并查集常用于以下场景：</p><ul><li><strong>网络连通性</strong>：判断网络中的两个节点是否连通。</li><li><strong>动态连通性问题</strong>：如图的连通分量计算。</li><li><strong>最小生成树</strong>：Kruskal算法中使用并查集来检测环路。</li></ul><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>并查集是一种高效解决动态连通性问题的数据结构。通过路径压缩和按秩合并的优化，可以实现几乎常数时间的合并和查找操作。掌握并查集对于解决很多图论问题和网络连通性问题非常有帮助。</p><h3 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a><a href="https://leetcode.cn/problems/longest-consecutive-sequence/description/">最长连续序列</a></h3><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 并查集的初始化</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; fa; <span class="comment">// 储存每个节点的root，初始化为自己</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; size; <span class="comment">// 储存以当前节点为root的节点数量，初始化只有自己一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找操作</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[x] != x) &#123;</span><br><span class="line">            fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> f, <span class="type">int</span> to)</span> </span>&#123;</span><br><span class="line">        f = <span class="built_in">find</span>(f);</span><br><span class="line">        to = <span class="built_in">find</span>(to);</span><br><span class="line">        <span class="keyword">if</span> (f != to) &#123;</span><br><span class="line">            fa[f] = to;</span><br><span class="line">            size[to] += size[f];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 去重</span></span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">numSet</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : numSet) &#123;</span><br><span class="line">            fa[num] = num;</span><br><span class="line">            size[num] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历集合并合并</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : numSet) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numSet.<span class="built_in">count</span>(num + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="built_in">merge</span>(num, num + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算最长连续序列的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [key, value] : size) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GPT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2024/08/22/Sorting-algorithms/"/>
      <url>/2024/08/22/Sorting-algorithms/</url>
      
        <content type="html"><![CDATA[<p>拓扑排序<br>找到做事情的先后顺序，拓扑排序的结果可能不是唯一的<br>如何排序?</p><ol><li>找出图中入度为 0 的点，然后输出</li><li>删除与该点连接的边</li><li>重复 1、2 操作，直到图中没有点或者没有入度为 0 的点为止</li></ol><p>实现拓扑排序<br>借助队列，来一次 BFS 即可</p><ol><li>初始化:把所有入度为 0 的点加入到队列中</li><li>当队列不为空的时候:拿出队头元素，加入到最终结果中;删除与该元素相连的边;判断:与删除边相连的点,是否入度变成 0 如果入度为 0，加入到队列中</li></ol><p>借助STL容器灵活建图<br>vector&lt;vector<int>&gt; edges;<br>unordered_map&lt;int,vector<int>&gt; edges;</p><p>根据算法流程，灵活建图<br>每个顶点的入度   vector<int> in;</p><h3 id="1课程表"><a href="#1课程表" class="headerlink" title="1课程表"></a>1<a href="https://leetcode.cn/problems/course-schedule/description/">课程表</a></h3><p>你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。</p><p>在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] &#x3D; [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。</p><ul><li>例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。</li></ul><p>请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.准备工作</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; edges;<span class="comment">//邻接表存图</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">in</span><span class="params">(numCourses)</span></span>;<span class="comment">//标记每个节点的入度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.建图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e:prerequisites)&#123;</span><br><span class="line">            <span class="type">int</span> a=e[<span class="number">0</span>],b=e[<span class="number">1</span>];</span><br><span class="line">            edges[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">            in[a]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.拓扑排序</span></span><br><span class="line">        a</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//bfs</span></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> t=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> a:edges[t])&#123;</span><br><span class="line">                in[a]--;</span><br><span class="line">                <span class="keyword">if</span>(in[a]==<span class="number">0</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(a);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.判断是否有环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2体育课测验-二"><a href="#2体育课测验-二" class="headerlink" title="2体育课测验(二)"></a>2<a href="https://www.nowcoder.com/practice/64a4c026b2aa4411984f560deec36323?tab=note">体育课测验(二)</a></h3><p>描述<br>体育课共有 numProject个考核项目，编号为 0到 numProject−1，考核中每两个项目被划分为一组得到分组数组<br>groupsi ，现规定若想完成项目 groupsi[0]，必须先完成 groupsi[1]。保证所有分组互不相同，<br>若分组情况能顺利完成考核，请返回任意的一个完成顺序,否则返回空数组 。</p><p>数据范围：<br>1≤numProject≤2000  1≤groupsi.length≤numProject∗(numProject−1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="type">int</span> numProject, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;&amp; groups)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">//1.准备工作</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">in</span><span class="params">(numProject,<span class="number">0</span>)</span></span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.建图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e:groups)&#123;</span><br><span class="line">            <span class="type">int</span> a=e[<span class="number">0</span>],b=e[<span class="number">1</span>];</span><br><span class="line">            edges[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">            in[a]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.拓扑排序</span></span><br><span class="line">        <span class="comment">//把所有入度为零的点加入到队列中</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numProject;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//bfs</span></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> t=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(t);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> a:edges[t])&#123;</span><br><span class="line">                in[a]--;</span><br><span class="line">                <span class="keyword">if</span>(in[a]==<span class="number">0</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(a);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.检查是否所有节点都被处理</span></span><br><span class="line">        <span class="keyword">if</span>(ans.<span class="built_in">size</span>()!=numProject)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>快速排序</p><h3 id="3数组排序"><a href="#3数组排序" class="headerlink" title="3数组排序"></a>3<a href="https://leetcode.cn/problems/sort-an-array/description/">数组排序</a></h3><p>给你一个整数数组 nums，请你将该数组升序排列。</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="built_in">qsort</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> key=<span class="built_in">get_rand</span>(nums,left,right);</span><br><span class="line">        <span class="type">int</span> i=left,l=left<span class="number">-1</span>,r=right+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;key) <span class="built_in">swap</span>(nums[++l],nums[i++]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(key==nums[i]) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">swap</span>(nums[i],nums[--r]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[left,l][l+1,r-1][r,right]</span></span><br><span class="line">        <span class="built_in">qsort</span>(nums,left,l);</span><br><span class="line">        <span class="built_in">qsort</span>(nums,r,right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_rand</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> r=<span class="built_in">rand</span>();</span><br><span class="line">        <span class="keyword">return</span> nums[r%(right-left+<span class="number">1</span>)+left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>归并排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        ret.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">Mergesort</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Mergesort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//选择中间位置</span></span><br><span class="line">        <span class="type">int</span> mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把左右区间排序</span></span><br><span class="line">        <span class="comment">//[left,mid][mid+1,right]</span></span><br><span class="line">        <span class="built_in">Mergesort</span>(nums,left,mid);</span><br><span class="line">        <span class="built_in">Mergesort</span>(nums,mid+<span class="number">1</span>,right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//合并两个有序数组</span></span><br><span class="line">        <span class="type">int</span> cur1=left,cur2=mid+<span class="number">1</span>,i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur1&lt;=mid&amp;&amp;cur2&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[i++]=nums[cur1]&lt;nums[cur2]?nums[cur1++]:nums[cur2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理没有遍历完的数组</span></span><br><span class="line">        <span class="keyword">while</span>(cur1&lt;=mid) ret[i++]=nums[cur1++];</span><br><span class="line">        <span class="keyword">while</span>(cur2&lt;=right) ret[i++]=nums[cur2++];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//还原</span></span><br><span class="line">        <span class="keyword">for</span>(i=left;i&lt;=right;i++)</span><br><span class="line">            nums[i]=ret[i-left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> wildcard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归</title>
      <link href="/2024/08/19/recursion/"/>
      <url>/2024/08/19/recursion/</url>
      
        <content type="html"><![CDATA[<h3 id="1五子棋"><a href="#1五子棋" class="headerlink" title="1五子棋"></a>1<a href="https://www.nowcoder.com/practice/a811535fed784ea492b63622c28c75c5?tpId=3&tags=&title=&difficulty=0&judgeStatus=0&sourceUrl=">五子棋</a></h3><p><strong>描述</strong></p><p>NowCoder最近爱上了五子棋，现在给你一个棋局，请你帮忙判断其中有没有五子连珠（超过五颗也算）。</p><p><strong>输入描述：</strong><br>输入有多组数据，每组数据为一张20x20的棋盘。<br>其中黑子用“*”表示，白子用“+”表示，空白位置用“.”表示。</p><p><strong>输出描述：</strong><br>如果棋盘上存在五子连珠（无论哪种颜色的棋子），输入“Yes”，否则输出“No”。</p><p>思路：<br>判断一个点位上的四个方向是否有一个存在五子连珠(0,1) (1,0) (1,1) (1,-1)</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkDirection</span><span class="params">(vector&lt;string&gt;&amp; board, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> dx, <span class="type">int</span> dy)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> player = board[x][y];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> newX = x + i * dx;</span><br><span class="line">        <span class="type">int</span> newY = y + i * dy;</span><br><span class="line">        <span class="keyword">if</span> (newX &lt; <span class="number">0</span> || newX &gt;= <span class="number">20</span> || newY &lt; <span class="number">0</span> || newY &gt;= <span class="number">20</span> ||</span><br><span class="line">                board[newX][newY] != player) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasFiveInARow</span><span class="params">(vector&lt;string&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">checkDirection</span>(board, i, j, <span class="number">1</span>, <span class="number">-1</span>) ||</span><br><span class="line">                        <span class="built_in">checkDirection</span>(board, i, j, <span class="number">0</span>, <span class="number">1</span>) || <span class="built_in">checkDirection</span>(board, i, j, <span class="number">1</span>, <span class="number">1</span>) ||</span><br><span class="line">                        <span class="built_in">checkDirection</span>(board, i, j, <span class="number">1</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">board</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; board[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            cin &gt;&gt; board[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">hasFiveInARow</span>(board)) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2kotori和迷宫"><a href="#2kotori和迷宫" class="headerlink" title="2kotori和迷宫"></a>2<a href="https://ac.nowcoder.com/acm/problem/50041">kotori和迷宫</a></h3><p><strong>题目描述</strong><br>kotori在一个n*m迷宫里，迷宫的最外层被岩浆淹没，无法涉足，迷宫内有k个出口。kotori只能上下左右四个方向移动。她想知道有多少出口是她能到达的，最近的出口离她有多远？</p><p><strong>输入描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行为两个整数n和m，代表迷宫的行和列数 (1≤n,m≤30)</span><br><span class="line">后面紧跟着n行长度为m的字符串来描述迷宫。&#x27;k&#x27;代表kotori开始的位置，</span><br><span class="line">&#x27;.&#x27;代表道路，&#x27;*&#x27;代表墙壁，&#x27;e&#x27;代表出口。保证输入合法。</span><br></pre></td></tr></table></figure><p><strong>输出描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">若有出口可以抵达，则输出2个整数，第一个代表kotori可选择的出口的数量，</span><br><span class="line">第二个代表kotori到最近的出口的步数。（注意，kotori到达出口一定会离开迷宫）</span><br><span class="line">若没有出口可以抵达，则输出-1。</span><br></pre></td></tr></table></figure><p>思路：<br>出口不止一个，需要比较进行比较 选择最优<br>BFS可以用来寻找最优方案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 定义方向数组，表示上下左右四个方向的移动</span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Position</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">maze</span><span class="params">(n)</span></span>;</span><br><span class="line">    queue&lt;Position&gt; q;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取迷宫并找到kotori的起始位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; maze[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maze[i][j] == <span class="string">&#x27;k&#x27;</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;i, j, <span class="number">0</span>&#125;);</span><br><span class="line">                visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> exit_count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> min_distance = <span class="number">0x3f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BFS搜索</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Position cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否到达出口</span></span><br><span class="line">        <span class="keyword">if</span> (maze[cur.x][cur.y] == <span class="string">&#x27;e&#x27;</span>) &#123;</span><br><span class="line">            exit_count++;</span><br><span class="line">            min_distance = <span class="built_in">min</span>(min_distance, cur.step);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扩展到四个方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> nx = cur.x + dx[i];</span><br><span class="line">            <span class="type">int</span> ny = cur.y + dy[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断新位置是否在迷宫内，并且可以走</span></span><br><span class="line">            <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; m &amp;&amp; !visited[nx][ny] &amp;&amp; maze[nx][ny] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                visited[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;nx, ny, cur.step + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">if</span> (exit_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; exit_count &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; min_distance &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3走迷宫"><a href="#3走迷宫" class="headerlink" title="3走迷宫"></a>3<a href="https://www.nowcoder.com/practice/6276dbbda7094978b0e9ebb183ba37b9">走迷宫</a></h3><p><strong>描述</strong><br>NowCoder最喜欢游乐场的迷宫游戏，他和小伙伴们比赛谁先走出迷宫。<br>现在把迷宫的地图给你，你能帮他算出最快走出迷宫需要多少步吗？</p><p><strong>输入描述：</strong><br>输入包含多组数据。<br>每组数据包含一个10*10，由“#”和“.”组成的迷宫。其中“#”代表墙；“.”代表通路。<br>入口在第一行第二列；出口在最后一行第九列。<br>从任意一个“.”点都能一步走到上下左右四个方向的“.”点。</p><p><strong>输出描述：</strong><br>对应每组数据，输出从入口到出口最短需要几步。</p><p>和上面的题目一样的思路BFS</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Position</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(vector&lt;string&gt;&amp; maze)</span></span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(<span class="number">10</span>,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(<span class="number">10</span>,<span class="literal">false</span>));</span><br><span class="line">    queue&lt;Position&gt; q;</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    visited[<span class="number">0</span>][<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        Position cur=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cur.x==<span class="number">9</span>&amp;&amp;cur.y==<span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> cur.step;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">            <span class="type">int</span> newX=cur.x+dx[k];</span><br><span class="line">            <span class="type">int</span> newY=cur.y+dy[k];</span><br><span class="line">            <span class="keyword">if</span>(newX&gt;=<span class="number">0</span>&amp;&amp;newX&lt;<span class="number">10</span>&amp;&amp;newY&gt;=<span class="number">0</span>&amp;&amp;newY&lt;<span class="number">10</span>&amp;&amp;!visited[newX][newY]&amp;&amp;maze[newX][newY]!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;newX,newY,cur.step+<span class="number">1</span>&#125;);</span><br><span class="line">                visited[newX][newY]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">maze</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;maze[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            cin&gt;&gt;maze[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;<span class="built_in">bfs</span>(maze)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4幸运的袋子"><a href="#4幸运的袋子" class="headerlink" title="4幸运的袋子"></a>4<a href="https://www.nowcoder.com/practice/a5190a7c3ec045ce9273beebdfe029ee?tpId=85&&tqId=29839&qru=/ta/2017test/question-ranking">幸运的袋子</a></h3><p><strong>描述</strong><br>一个袋子里面有n个球，每个球上面都有一个号码(拥有相同号码的球是无区别的)。如果一个袋子是幸运的当且仅当所有球的号码的和大于所有球的号码的积。<br>例如：如果袋子里面的球的号码是{1, 1, 2, 3}，这个袋子就是幸运的，因为1 + 1 + 2 + 3 &gt; 1 * 1 * 2 * 3<br>你可以适当从袋子里移除一些球(可以移除0个,但是别移除完)，要使移除后的袋子是幸运的。现在让你编程计算一下你可以获得的多少种不同的幸运的袋子。</p><p><strong>输入描述：</strong><br>第一行输入一个正整数n(n ≤ 1000) 第二行为n个数正整数xi(xi ≤ 1000)</p><p><strong>输出描述：</strong><br>输出可以产生的幸运的袋子数</p><p>思路：先排序</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> pos,<span class="type">int</span> sum,<span class="type">int</span> multi)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=pos;i&lt;arr.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        sum+=arr[i];</span><br><span class="line">        multi*=arr[i];</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;multi)&#123;</span><br><span class="line">            count+=<span class="number">1</span>+<span class="built_in">dfs</span>(arr,i+<span class="number">1</span>,sum,multi);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[i]==<span class="number">1</span>)&#123;</span><br><span class="line">            count+=<span class="built_in">dfs</span>(arr,i+<span class="number">1</span>,sum,multi);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        sum-=arr[i];</span><br><span class="line">        multi/=arr[i];</span><br><span class="line">        <span class="comment">//去重</span></span><br><span class="line">        <span class="keyword">while</span>((i+<span class="number">1</span>&lt;arr.<span class="built_in">size</span>())&amp;&amp;arr[i]==arr[i+<span class="number">1</span>]) i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());</span><br><span class="line">    cout&lt;&lt;<span class="built_in">dfs</span>(arr,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5矩阵中的最长递增路径"><a href="#5矩阵中的最长递增路径" class="headerlink" title="5矩阵中的最长递增路径"></a>5<a href="https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/description/">矩阵中的最长递增路径</a></h3><p>给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。</p><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="type">int</span> memo[<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestIncreasingPath</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="type">int</span> ret = <span class="number">1</span>;<span class="comment">//至少有一个数</span></span><br><span class="line">            <span class="keyword">if</span> (memo[x][y] != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> memo[x][y];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                <span class="type">int</span> newX = x + dx[k];</span><br><span class="line">                <span class="type">int</span> newY = y + dy[k];</span><br><span class="line">                <span class="keyword">if</span> (newX &gt;= <span class="number">0</span> &amp;&amp; newX &lt; m &amp;&amp; newY &gt;= <span class="number">0</span> &amp;&amp; newY &lt; n &amp;&amp;</span><br><span class="line">                    matrix[x][y] &lt; matrix[newX][newY]) &#123;</span><br><span class="line">                    ret = <span class="built_in">max</span>(ret, <span class="built_in">dfs</span>(newX, newY) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            memo[x][y] = ret;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, <span class="built_in">dfs</span>(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6滑雪"><a href="#6滑雪" class="headerlink" title="6滑雪"></a>6<a href="https://www.nowcoder.com/practice/36d613e0d7c84a9ba3af3ab0047a35e0?tpId=230&tqId=2362693&qru=/ta/dynamic-programming/question-ranking&sourceUrl=/exam/oj">滑雪</a></h3><p><strong>描述</strong></p><p>给定一个 n×m  的矩阵，矩阵中的数字表示滑雪场各个区域的高度，<br>你可以选择从任意一个区域出发，并滑向任意一个周边的高度严格更低的区域（周边的定义是上下左右相邻的区域）。<br>请问整个滑雪场中最长的滑道有多长？(滑道的定义是从一个点出发的一条高度递减的路线）。<br>(本题和矩阵最长递增路径类似，该题是当年NOIP的一道经典题)</p><p>数据范围： 1≤n,m≤100 ，矩阵中的数字满足  1≤val≤1000</p><p><strong>输入描述：</strong></p><p>第一行输入两个正整数 n 和 m 表示矩阵的长宽。<br>后续 n 行输入中每行有 m 个正整数，表示矩阵的各个元素大小。</p><p><strong>输出描述：</strong></p><p>输出最长递减路线。</p><p>思路与矩阵中的最长递增路径一样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> memo[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">map</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            cin&gt;&gt;map[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> i,<span class="type">int</span> j)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(memo[i][j]!=<span class="number">0</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        <span class="type">int</span> ret=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">            <span class="type">int</span> x=i+dx[k];</span><br><span class="line">            <span class="type">int</span> y=j+dy[k];</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;n&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;m&amp;&amp;map[x][y]&lt;map[i][j])&#123;</span><br><span class="line">                ret=<span class="built_in">max</span>(ret,<span class="built_in">dfs</span>(x,y)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[i][j]=ret;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,<span class="built_in">dfs</span>(i,j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7迷宫问题"><a href="#7迷宫问题" class="headerlink" title="7迷宫问题"></a>7<a href="https://www.nowcoder.com/practice/cf24906056f4488c9ddb132f317e03bc?tpId=37&tqId=21266&qru=/exam/oj/ta&sourceUrl=/exam/oj/ta?tpId=37&difficulty=undefined&judgeStatus=undefined&tags=&title=">迷宫问题</a></h3><p><strong>描述</strong></p><p>定义一个二维数组 N*M ，如 5 × 5 数组下所示：</p><p>int maze[5][5] &#x3D; {<br>0, 1, 0, 0, 0,<br>0, 1, 1, 1, 0,<br>0, 0, 0, 0, 0,<br>0, 1, 1, 1, 0,<br>0, 0, 0, 1, 0,<br>};</p><p>它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，<br>要求编程序找出从左上角到右下角的路线。入口点为[0,0],既第一格是可以走的路。</p><p>数据范围： 2≤n,m≤10  ， 输入的内容只包含 0≤val≤1</p><p><strong>输入描述：</strong></p><p>输入两个整数，分别表示二维数组的行数，列数。再输入相应的数组，其中的1表示墙壁，<br>0表示可以走的路。数据保证有唯一解,不考虑有多解的情况，即迷宫只有一条通道。</p><p><strong>输出描述：</strong></p><p>左上角到右下角的最短路径，格式如样例所示。</p><p>经典BFS 和上述迷宫类似 这里需要输出最佳路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int ROW,COL;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; maze;</span><br><span class="line">vector&lt;vector&lt;bool&gt;&gt; visited;</span><br><span class="line">int dx[4]=&#123;0,0,1,-1&#125;;</span><br><span class="line">int dy[4]=&#123;1,-1,0,0&#125;;</span><br><span class="line"></span><br><span class="line">struct Node&#123;</span><br><span class="line">    int x,y;</span><br><span class="line">    vector&lt;pair&lt;int,int&gt;&gt; path;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool isValid(int i,int j)&#123;</span><br><span class="line">    return (i&gt;=0&amp;&amp;i&lt;ROW&amp;&amp;j&gt;=0&amp;&amp;j&lt;COL&amp;&amp;maze[i][j]==0&amp;&amp;!visited[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;pair&lt;int,int&gt;&gt;bfs(vector&lt;vector&lt;int&gt;&gt;&amp; maze)&#123;</span><br><span class="line">    queue&lt;Node&gt; q;</span><br><span class="line">    q.push(&#123;0,0,&#123;&#123;0,0&#125;&#125;&#125;);</span><br><span class="line">    visited[0][0]=true;</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        Node cur=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        if(cur.x==ROW-1&amp;&amp;cur.y==COL-1)&#123;</span><br><span class="line">            return cur.path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int k=0;k&lt;4;k++)&#123;</span><br><span class="line">            int newX=cur.x+dx[k];</span><br><span class="line">            int newY=cur.y+dy[k];</span><br><span class="line">            if(isValid(newX, newY))&#123;</span><br><span class="line">                visited[newX][newY]=true;</span><br><span class="line">                vector&lt;pair&lt;int,int&gt;&gt; newpath=cur.path;</span><br><span class="line">                newpath.push_back(&#123;newX,newY&#125;);</span><br><span class="line">                q.push(&#123;newX,newY,&#123;newpath&#125;&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;&gt;ROW&gt;&gt;COL;</span><br><span class="line">    maze=vector&lt;vector&lt;int&gt;&gt;(ROW,vector&lt;int&gt;(COL));</span><br><span class="line">    visited=vector&lt;vector&lt;bool&gt;&gt;(ROW,vector&lt;bool&gt;(COL,false));</span><br><span class="line">    for(int i=0;i&lt;ROW;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;COL;j++)&#123;</span><br><span class="line">            cin&gt;&gt;maze[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;pair&lt;int,int&gt;&gt; path=bfs(maze);</span><br><span class="line">    for(int i=0;i&lt;path.size();i++)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;(&quot;&lt;&lt;path[i].first&lt;&lt;&quot;,&quot;&lt;&lt;path[i].second&lt;&lt;&quot;)&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8红与黑"><a href="#8红与黑" class="headerlink" title="8红与黑"></a>8<a href="https://www.nowcoder.com/practice/5017fd2fc5c84f78bbaed4777996213a?tpId=3&tqId=10879&qru=/ta/hackathon/question-ranking">红与黑</a></h3><p><strong>描述</strong></p><p>有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。你站在其中一块黑色的瓷砖上，<br>只能向相邻的（上下左右四个方向）黑色瓷砖移动。请写一个程序，计算你总共能够到达多少块黑色的瓷砖。</p><p><strong>输入描述：</strong></p><p>输入包含多组数据。<br>每组数据第一行是两个整数 m 和 n（1≤m, n≤20）。紧接着 m 行，每行包括 n 个字符。每个字符表示一块瓷砖的颜色，规则如下：</p><ol><li>“.”：黑色的瓷砖；</li><li>“#”：白色的瓷砖；</li><li>“@”：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。</li></ol><p><strong>输出描述：</strong></p><p>对应每组数据，输出总共能够到达多少块黑色的瓷砖。</p><p>DFS</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="type">int</span> m, n;</span><br><span class="line">vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; grid;</span><br><span class="line">vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; visited;</span><br><span class="line"><span class="type">int</span> startX, startY;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义方向数组，上下左右四个方向</span></span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否在网格范围内</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == <span class="string">&#x27;.&#x27;</span> &amp;&amp;</span><br><span class="line">           !visited[x][y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深度优先搜索</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    visited[x][y]=<span class="literal">true</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> newX=x+dx[i];</span><br><span class="line">        <span class="type">int</span> newY=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isValid</span>(newX, newY))&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(newX,newY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; m &gt;&gt; n) &#123;</span><br><span class="line">        grid=vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;(m,<span class="built_in">vector</span>&lt;<span class="type">char</span>&gt;(n));</span><br><span class="line">        visited=vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;(m,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                cin&gt;&gt;grid[i][j];</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;@&#x27;</span>)&#123;</span><br><span class="line">                    startX=i;</span><br><span class="line">                    startY=j;</span><br><span class="line">                    grid[i][j]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(startX,startY);</span><br><span class="line">        cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9树根"><a href="#9树根" class="headerlink" title="9树根"></a>9<a href="https://www.nowcoder.com/questionTerminal/e2422543519249f292d8435394ab82fe">树根</a></h3><p>数根可以通过把一个数的各个位上的数字加起来得到。如果得到的数是一位数，那么这个数就是数根；<br>如果结果是两位数或者包括更多位的数字，那么再把这些数字加起来。如此进行下去，直到得到是一位数为止。<br>比如，对于24 来说，把2 和4 相加得到6，由于6 是一位数，因此6 是24 的数根。<br>再比如39，把3 和9 加起来得到12，由于12 不是一位数，因此还得把1 和2 加起来，最后得到3，这是一个一位数，因此3 是39 的数根。<br>现在给你一个正整数，输出它的数根。</p><p><strong>输入描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入包含多组数据。</span><br><span class="line">每组数据数据包含一个正整数n（1≤n≤10E1000）。</span><br></pre></td></tr></table></figure><p><strong>输出描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对应每一组数据，输出该正整数的数根。</span><br></pre></td></tr></table></figure><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rootNum</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> rootnum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        rootnum+=num%<span class="number">10</span>;</span><br><span class="line">        num/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(rootnum&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">        rootnum=<span class="built_in">rootNum</span>(rootnum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rootnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;str)&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch:str)&#123;</span><br><span class="line">            sum+=ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">rootNum</span>(sum)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10跳台阶"><a href="#10跳台阶" class="headerlink" title="10跳台阶"></a>10<a href="https://www.nowcoder.com/practice/bfb2a2b3cdbd4bd6bba0d4dca69aa3f0?tpId=230&tqId=39749">跳台阶</a></h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。<br>数据范围： 1≤n≤40<br>要求：时间复杂度： O(n) ，空间复杂度： O(1)</p><p>经典斐波那契数列</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Fib</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">3</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">return</span> (<span class="built_in">Fib</span>(n<span class="number">-1</span>)+<span class="built_in">Fib</span>(n<span class="number">-2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">Fib</span>(n)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11跳台阶扩展问题"><a href="#11跳台阶扩展问题" class="headerlink" title="11跳台阶扩展问题"></a>11<a href="https://www.nowcoder.com/questionTerminal/22243d016f6b47f2a6928b4313c85387">跳台阶扩展问题</a></h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶(n为正整数)总共有多少种跳法。</p><p>数据范围： 1≤n≤20<br>进阶：空间复杂度 O(1) ， 时间复杂度 O(1)</p><p>数据归纳<br>假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1)；<br>假定第一次跳的是2阶，那么剩下的是n-2个台 阶，跳法是f(n-2)；<br>假定第一次跳的是3阶，那么剩下的是n-3个台阶，跳法是f(n-3)……<br>假定第一次跳的是n-1阶， 那么剩下的是1个台阶，跳法是f(1)；<br>假定第一次跳的是n阶，那么剩下的是0个台阶，跳法是1种；</p><p>总结 f(n)&#x3D;2^(n-1)</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>)) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> wildcard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2024/08/19/Data-structure/"/>
      <url>/2024/08/19/Data-structure/</url>
      
        <content type="html"><![CDATA[<p>优先队列 priority_queue<br>仿函数less 升序 -》大根堆<br>仿函数greater 降序 -》 小根堆</p><p>仿函数-》重载()</p><h3 id="1合并-K-个升序链表"><a href="#1合并-K-个升序链表" class="headerlink" title="1合并 K 个升序链表"></a>1<a href="https://leetcode.cn/problems/merge-k-sorted-lists/description/">合并 K 个升序链表</a></h3><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p>思路：<br>将所有的节点放到优先队列中  一个一个拿出来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> l1-&gt;val &gt; l2-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp&gt; pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> head : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head) &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(head);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* dummy =</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>); <span class="comment">// 哨兵节点，作为合并后链表头节点的前一个节点</span></span><br><span class="line">        <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;     <span class="comment">// 循环直到堆为空</span></span><br><span class="line">            <span class="keyword">auto</span> node = pq.<span class="built_in">top</span>(); <span class="comment">// 剩余节点中的最小节点</span></span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;next) &#123; <span class="comment">// 下一个节点不为空</span></span><br><span class="line">                pq.<span class="built_in">push</span>(node-&gt;next); <span class="comment">// 下一个节点有可能是最小节点，入堆</span></span><br><span class="line">            &#125;</span><br><span class="line">            cur-&gt;next = node; <span class="comment">// 合并到新链表中</span></span><br><span class="line">            cur = cur-&gt;next;  <span class="comment">// 准备合并下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next; <span class="comment">// 哨兵节点的下一个节点就是新链表的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2最近公共祖先"><a href="#2最近公共祖先" class="headerlink" title="2最近公共祖先"></a>2<a href="https://www.nowcoder.com/questionTerminal/70e00e490b454006976c1fdf47f155d9">最近公共祖先</a></h3><p>将一棵无穷大满二叉树的结点按根结点一层一层地从左往右编号，根结点编号为1。现给定a，b为两个结点。<br>设计一个算法，返回a、b最近的公共祖先的编号。注意其祖先也可能是结点本身。</p><p>测试样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2，3</span><br><span class="line">返回：1</span><br></pre></td></tr></table></figure><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LCA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLCA</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">while</span>(a!=b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">                a/=<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                b/=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3从中序与后序遍历序列构造二叉树"><a href="#3从中序与后序遍历序列构造二叉树" class="headerlink" title="3从中序与后序遍历序列构造二叉树"></a>3<a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/">从中序与后序遍历序列构造二叉树</a></h3><p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历，<br>postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p><p>实例</p><img src="/2024/08/19/Data-structure/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240902190557.png" class=""><p>输入：inorder &#x3D; [9,3,15,20,7], postorder &#x3D; [9,15,7,20,3]</p><p>输出：[3,9,20,null,null,15,7]</p><p>先根据后序遍历得知根节点 在中序遍历中的通过根节点分为两部分 左子树 右子树 递归即可</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=inorder.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; index;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            index[inorder[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function&lt;TreeNode*(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> in_l,<span class="type">int</span> in_r,<span class="type">int</span> post_l,<span class="type">int</span> post_r)-&gt;TreeNode*&#123;</span><br><span class="line">            <span class="keyword">if</span>(post_l==post_r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> left_size=index[postorder[post_r<span class="number">-1</span>]]-in_l;</span><br><span class="line">            TreeNode* left=<span class="built_in">dfs</span>(in_l,in_l+left_size,post_l,post_l+left_size);</span><br><span class="line">            TreeNode* right=<span class="built_in">dfs</span>(in_l+left_size+<span class="number">1</span>,in_r,post_l+left_size,post_r<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(postorder[post_r<span class="number">-1</span>],left,right);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>,n,<span class="number">0</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4删除二叉搜索树中的节点"><a href="#4删除二叉搜索树中的节点" class="headerlink" title="4删除二叉搜索树中的节点"></a>4<a href="https://leetcode.cn/problems/delete-node-in-a-bst/description/">删除二叉搜索树中的节点</a></h3><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><p>首先找到需要删除的节点；</p><p>如果找到了，删除它。</p><p>根据二叉搜索树的性质</p><p>如果目标节点大于当前节点值，则去右子树中删除；</p><p>如果目标节点小于当前节点值，则去左子树中删除；</p><p>如果目标节点就是当前节点，分为以下三种情况：</p><p>其无左子：其右子顶替其位置，删除了该节点；</p><p>其无右子：其左子顶替其位置，删除了该节点；</p><p>其左右子节点都有：其左子树转移到其右子树的最左节点的左子树上，然后右子树顶替其位置，由此删除了该节点。</p><img src="/2024/08/19/Data-structure/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240902201003.png" class=""><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (key &gt; root-&gt;val)    root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);     <span class="comment">// 去右子树删除</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; root-&gt;val)    root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);  <span class="comment">// 去左子树删除</span></span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">// 当前节点就是要删除的节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (! root-&gt;left)   <span class="keyword">return</span> root-&gt;right; <span class="comment">// 情况1，欲删除节点无左子</span></span><br><span class="line">            <span class="keyword">if</span> (! root-&gt;right)  <span class="keyword">return</span> root-&gt;left;  <span class="comment">// 情况2，欲删除节点无右子</span></span><br><span class="line">            TreeNode* node = root-&gt;right;           <span class="comment">// 情况3，欲删除节点左右子都有 </span></span><br><span class="line">            <span class="keyword">while</span> (node-&gt;left)          <span class="comment">// 寻找欲删除节点右子树的最左节点</span></span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            node-&gt;left = root-&gt;left;    <span class="comment">// 将欲删除节点的左子树成为其右子树的最左节点的左子树</span></span><br><span class="line">            root = root-&gt;right;         <span class="comment">// 欲删除节点的右子顶替其位置，节点被删除</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> wildcard </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常规题</title>
      <link href="/2024/08/17/Regular-questions/"/>
      <url>/2024/08/17/Regular-questions/</url>
      
        <content type="html"><![CDATA[<h3 id="1素数回文"><a href="#1素数回文" class="headerlink" title="1素数回文"></a>1<a href="https://www.nowcoder.com/practice/d638855898fb4d22bc0ae9314fed956f?tpId=290&tqId=140152&qru=/ta/beginner-programmers/question-ranking&sourceUrl=/exam/oj?page=1&tab=%25E8%25AF%25AD%25E6%25B3%2595%25E7%25AF%2587&topicId=290">素数回文</a></h3><p><strong>描述</strong><br>现在给出一个素数，这个素数满足两点：</p><ol><li>只由1-9组成，并且每个数只出现一次，如13,23,1289。</li><li>位数从高到低为递减或递增，如2459，87631。</li></ol><p>请你判断一下，这个素数的回文数是否为素数（13的回文数是131,127的回文数是12721）。</p><p><strong>输入描述：</strong><br>输入只有1行。<br>第1行输入一个整数t，保证t为素数。<br>数据保证：9&lt;t&lt;109</p><p><strong>输出描述：</strong><br>输出一行字符串，如果t的回文数仍是素数，则输出“prime”，否则输出”noprime”。</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">long</span> <span class="type">long</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">2</span>;i*i&lt;=num;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    string tmp=t;</span><br><span class="line">    <span class="built_in">reverse</span>(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>());</span><br><span class="line">    tmp.<span class="built_in">erase</span>(tmp.<span class="built_in">begin</span>());</span><br><span class="line">    t+=tmp;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ret=<span class="built_in">atol</span>(t.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isPrime</span>(ret)) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;prime&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;noprime&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2活动安排"><a href="#2活动安排" class="headerlink" title="2活动安排"></a>2<a href="https://www.nowcoder.com/practice/16d971e9e42e4f3b9b1e2b8794796a43?tpId=308&tqId=2373697&qru=/ta/algorithm-start/question-ranking&sourceUrl=/exam/oj?page=1&tab=%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587&topicId=308">活动安排</a></h3><p><strong>描述</strong><br>给定 n 个活动，每个活动安排的时间为[ai,bi)<br>求最多可以选择多少个活动，满足选择的活动时间两两之间没有重合。</p><p><strong>输入描述：</strong><br>第一行输入一个整数<br>n (1 ≤ n ≤ 2*10^5)，表示可选活动个数。<br>接下来的 n 行，每行输入两个整数 ai , bi(0 ≤ ai &lt;bi ≤ 10^ 9 )，表示第 i 个活动的时间。</p><p><strong>输出描述：</strong><br>输出一行一个整数，表示最多可选择的活动数。</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Activity</span>&#123;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(Activity a,Activity b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.end&lt;b.end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="function">vector&lt;Activity&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;arr[i].start&gt;&gt;arr[i].end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>(),compare);</span><br><span class="line">    <span class="type">int</span> count=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> prevEnd=arr[<span class="number">0</span>].end;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i].start&gt;=prevEnd)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            prevEnd=arr[i].end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3手套"><a href="#3手套" class="headerlink" title="3手套"></a>3<a href="https://www.nowcoder.com/practice/365d5722fff640a0b6684391153e58d8?tpId=49&&tqId=29337&qru=/ta/2016test/question-ranking">手套</a></h3><p><strong>描述</strong></p><p>在地下室里放着n种颜色的手套，手套分左右手，但是每种颜色的左右手手套个数不一定相同。A先生现在要出门，<br>所以他要去地下室选手套。但是昏暗的灯光让他无法分辨手套的颜色，只能分辨出左右手。所以他会多拿一些手套，<br>然后选出一双颜色相同的左右手手套。现在的问题是，他至少要拿多少只手套(左手加右手)，才能保证一定能选出一双颜色相同的手套。<br>给定颜色种数n(1≤n≤13),同时给定两个长度为n的数组left,right,分别代表每种颜色左右手手套的数量。数据保证左右的手套总数均不超过26，且一定存在至少一种合法方案。</p><p><strong>测试样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4,[0,7,1,6],[1,5,0,6]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回：10(解释：可以左手手套取2只，右手手套取8只)</span><br></pre></td></tr></table></figure><p>思路：</p><p>如果某个颜色没有手套，就必须得把该颜色对应的另一边手套累加起来。<br>先计算出左手和右手手套的总数，然后减去各自的最少的数再加一<br>这样就可以保证取出的手套至少每种都有一只<br>计算总数的时候，要找出手套数量最少的那个颜色<br>比较两者较小的那个数，决定先取左手还是先取右手<br>最后再加上另一种手套的一只就行<br>当左右手中存在手套为零时，可以进行“忽略”</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Gloves</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinimum</span><span class="params">(<span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt; left, vector&lt;<span class="type">int</span>&gt; right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> leftsum = <span class="number">0</span>, leftmin = INT_MAX, rightsum = <span class="number">0</span>, rightmin = INT_MAX;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left[i] == <span class="number">0</span> || right[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                ans += left[i] + right[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                leftsum += left[i];</span><br><span class="line">                leftmin = <span class="built_in">min</span>(leftmin, left[i]);</span><br><span class="line">                rightsum += right[i];</span><br><span class="line">                rightmin = <span class="built_in">min</span>(rightmin, right[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += <span class="built_in">min</span>(leftsum - leftmin + <span class="number">1</span>, rightsum - rightmin + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4有假币"><a href="#4有假币" class="headerlink" title="4有假币"></a>4<a href="https://www.nowcoder.com/questionTerminal/1d18c0841e64454cbc3afaea05e2f63c">有假币</a></h3><p>居然有假币！ 现在猪肉涨了，但是农民的工资却不见涨啊，没钱怎么买猪肉啊。nowcoder这就去买猪肉，<br>结果找来的零钱中有假币！！！可惜nowcoder 一不小心把它混进了一堆真币里面去了。<br>只知道假币的重量比真币的质量要轻，给你一个天平（天平两端能容纳无限个硬币），<br>请用最快的时间把那个可恶的假币找出来。</p><p><strong>输入描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1≤n≤2^30,输入0结束程序。</span><br></pre></td></tr></table></figure><p><strong>输出描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最多要称几次一定能把那个假币找出来？</span><br></pre></td></tr></table></figure><p>思路：<br>平均分三份是最快的方法，两份进行称重（对比出三个的重量 ），后对最重的那份再次进行称重，<br>直到称重的个数不足2个时则结束，获得假币 如果无法平均分3分则余数要么是1要么是2，<br>因为是要最多称几次，n&#x3D;n&#x2F;3+1 满足每次取最大 分称3份，取两份一样多的过秤，<br>然后把三份中最多的那份继续分，直到硬币剩余0或1时截至</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">3</span>)&#123;</span><br><span class="line">                n=n/<span class="number">3</span>+<span class="number">1</span>;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                n/=<span class="number">3</span>;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5逆波兰表达式求值"><a href="#5逆波兰表达式求值" class="headerlink" title="5逆波兰表达式求值"></a>5<a href="https://leetcode.cn/problems/8Zf90G/description/">逆波兰表达式求值</a></h3><p>根据 逆波兰表示法，求该后缀表达式的计算结果。</p><p>有效的算符包括 +、-、*、&#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p>说明：</p><ul><li>整数除法只保留整数部分。</li><li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li></ul><p>经典后序遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNumber</span><span class="params">(string ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(ch==<span class="string">&quot;+&quot;</span>||ch==<span class="string">&quot;-&quot;</span>||ch==<span class="string">&quot;*&quot;</span>||ch==<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> n=tokens.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            string tmp=tokens[i];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isNumber</span>(tmp))&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">atoi</span>(tmp.<span class="built_in">c_str</span>()));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> num2=st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> num1=st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">switch</span>(tmp[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                        st.<span class="built_in">push</span>(num1+num2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                        st.<span class="built_in">push</span>(num1-num2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                        st.<span class="built_in">push</span>(num1*num2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                        st.<span class="built_in">push</span>(num1/num2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6电话号码"><a href="#6电话号码" class="headerlink" title="6电话号码"></a>6<a href="https://www.nowcoder.com/practice/ceb89f19187b4de3997d9cdef2d551e8?tpId=3&tqId=10926&qru=/ta/hackathon/question-ranking">电话号码</a></h3><p><strong>描述</strong></p><img src="/2024/08/17/Regular-questions/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240818181439.png" class=""><p>上图是一个电话的九宫格，如你所见一个数字对应一些字母，因此在国外企业喜欢把电话号码设计成与自己公司名字相对应。<br>例如公司的Help Desk号码是4357，因为4对应H、3对应E、5对应L、7对应P，因此4357就是HELP。<br>同理，TUT-GLOP就代表888-4567、310-GINO代表310-4466。<br>NowCoder刚进入外企，并不习惯这样的命名方式，现在给你一串电话号码列表，请你帮他转换成数字形式的号码，并去除重复的部分。</p><p><strong>输入描述：</strong><br>输入包含多组数据。<br>每组数据第一行包含一个正整数n（1≤n≤1024）。<br>紧接着n行，每行包含一个电话号码，电话号码仅由连字符“-”、数字和大写字母组成。<br>没有连续出现的连字符，并且排除连字符后长度始终为7（美国电话号码只有7位）。</p><p><strong>输出描述：</strong><br>对应每一组输入，按照字典顺序输出不重复的标准数字形式电话号码，即“xxx-xxxx”形式。<br>每个电话号码占一行，每组数据之后输出一个空行作为间隔符。</p><p><strong>注意去重</strong><br>不采取数组的方式存储数据，采用循环每次处理一个号码  isdigit isupper</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string alpha=<span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line">    string num=  <span class="string">&quot;22233344455566677778889999&quot;</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">char</span>&gt; map;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        map[alpha[i]]=num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    set&lt;string&gt; set;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        set.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            string line;</span><br><span class="line">            cin&gt;&gt;line;</span><br><span class="line">            string ans;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> ch:line)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isdigit</span>(ch))&#123;</span><br><span class="line">                    ans+=ch;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isupper</span>(ch))&#123;</span><br><span class="line">                    ans+=map[ch];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=ans.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">3</span>)+<span class="string">&quot;-&quot;</span>+ans.<span class="built_in">substr</span>(<span class="number">3</span>);</span><br><span class="line">            set.<span class="built_in">insert</span>(ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str:set)&#123;</span><br><span class="line">            cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7查找兄弟单词"><a href="#7查找兄弟单词" class="headerlink" title="7查找兄弟单词"></a>7<a href="https://www.nowcoder.com/practice/03ba8aeeef73400ca7a37a5f3370fe68?tpId=37&tqId=21250&qru=/exam/oj/ta&sourceUrl=/exam/oj/ta?tpId=37&difficulty=undefined&judgeStatus=undefined&tags=&title=">查找兄弟单词</a></h3><p><strong>描述</strong></p><p>定义一个单词的“兄弟单词”为：交换该单词字母顺序（注：可以交换任意次），而不添加、删除、修改原有的字母就能生成的单词。<br>兄弟单词要求和原来的单词不同。例如： ab 和 ba 是兄弟单词。 ab 和 ab 则不是兄弟单词。<br>现在给定你 n 个单词，另外再给你一个单词 x ，让你寻找 x 的兄弟单词里，按字典序排列后的第 k 个单词是什么？<br>注意：字典中可能有重复单词。</p><p>数据范围： 1≤n≤1000 ，输入的字符串长度满足 1≤len(str)≤10  ， 1≤k&lt;n</p><p><strong>输入描述：</strong></p><p>输入只有一行。 先输入字典中单词的个数n，再输入n个单词作为字典单词。 然后输入一个单词x 最后后输入一个整数k</p><p><strong>输出描述：</strong></p><p>第一行输出查找到x的兄弟单词的个数m 第二行输出查找到的按照字典顺序排序后的第k个兄弟单词，没有符合第k个的话则不用输出。</p><ol><li>将字典中的单词先放到 vector 中</li><li>将 vector 进行排序</li><li>isBrother 函数依次判定每个输入的单词是否是兄弟单词</li><li>判定兄弟单词的规则是 : 先判定长度;如果长度相同, 再看是否是完全相同(完全相同不算兄弟);然后将两个单词排序, 排序相同才是真兄弟单词.</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBrother</span><span class="params">(string str1,string str2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str1==str2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(str1.<span class="built_in">length</span>()!=str2.<span class="built_in">length</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">sort</span>(str1.<span class="built_in">begin</span>(),str1.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(str2.<span class="built_in">begin</span>(),str2.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> str1==str2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;arr[i];</span><br><span class="line">    string dict;</span><br><span class="line">    cin&gt;&gt;dict;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    string ans=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isBrother</span>(arr[i], dict))&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count==k)&#123;</span><br><span class="line">                ans=arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(count&gt;=k)&#123;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板<br>一类是有前置或者后置空格的，另一类是没有前置和后置空格的。<br>1、如果有前后置空格，那么必须判断临时字符串非空才能输出，否则会输出空串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">s += <span class="string">&quot; &quot;</span>; <span class="comment">//这里在最后一个字符位置加上空格，这样最后一个字符串就不会遗漏</span></span><br><span class="line">string temp = <span class="string">&quot;&quot;</span>;  <span class="comment">//临时字符串</span></span><br><span class="line">vector&lt;string&gt; res; <span class="comment">//存放字符串的数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> ch : s)  <span class="comment">//遍历字符句子</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>) <span class="comment">//遇到空格</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!temp.<span class="built_in">empty</span>()) <span class="comment">//临时字符串非空</span></span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            temp.<span class="built_in">clear</span>();  <span class="comment">//清空临时字符串</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        temp += ch; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、没有前后置的空格不需要判断空串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s += <span class="string">&quot; &quot;</span>;</span><br><span class="line">    string temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            temp.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp += ch;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="8单词倒排"><a href="#8单词倒排" class="headerlink" title="8单词倒排"></a>8<a href="https://www.nowcoder.com/practice/81544a4989df4109b33c2d65037c5836?tpId=37&tqId=38366&qru=/exam/oj/ta&sourceUrl=/exam/oj/ta?tpId=37&difficulty=undefined&judgeStatus=undefined&tags=&title=">单词倒排</a></h3><p><strong>描述</strong></p><p>对字符串中的所有单词进行倒排。</p><p>说明：</p><ol><li><p>构成单词的字符只有26个大写或小写英文字母；</p></li><li><p>非构成单词的字符均视为单词间隔符；</p></li><li><p>要求倒排后的单词间隔符以一个空格表示；如果原字符串中相邻单词间有多个间隔符时，倒排转换后也只允许出现一个空格间隔符；</p></li><li><p>每个单词最长20个字母；</p></li></ol><p>数据范围：字符串长度满足 1≤n≤10000</p><p><strong>输入描述：</strong></p><p>输入一行，表示用来倒排的句子</p><p><strong>输出描述：</strong></p><p>输出句子的倒排结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="built_in">getline</span>(cin,str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch:str)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isalpha</span>(ch))&#123;</span><br><span class="line">            ch=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    ss&lt;&lt;str;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="keyword">while</span>(ss&gt;&gt;str)&#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=ans.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans[<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9螺旋矩阵"><a href="#9螺旋矩阵" class="headerlink" title="9螺旋矩阵"></a>9<a href="https://leetcode.cn/problems/spiral-matrix/description/">螺旋矩阵</a></h3><p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p><p>从左往右 从上往下 从右往左 从下往上</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=matrix[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>,t=<span class="number">0</span>,b=matrix.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//从左往右</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++) ans.<span class="built_in">push_back</span>(matrix[t][i]);</span><br><span class="line">            <span class="keyword">if</span>(++t&gt;b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//从上往下</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=t;i&lt;=b;i++) ans.<span class="built_in">push_back</span>(matrix[i][r]);</span><br><span class="line">            <span class="keyword">if</span>(--r&lt;l) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//从右往左</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=r;i&gt;=l;i--) ans.<span class="built_in">push_back</span>(matrix[b][i]);</span><br><span class="line">            <span class="keyword">if</span>(--b&lt;t) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//从下往上</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=b;i&gt;=t;i--) ans.<span class="built_in">push_back</span>(matrix[i][l]);</span><br><span class="line">            <span class="keyword">if</span>(++l&gt;r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="10划分数组"><a href="#10划分数组" class="headerlink" title="10划分数组"></a>10<a href="https://www.nowcoder.com/questionTerminal/5662139e24bc4ad3a3b81fb829219ebb?page=1&onlyReference=false">划分数组</a></h3><p>给定一个数组arr长度为N，你可以把任意长度大于0且小于N的前缀作为左部分，剩下的 作为右部分。<br>但是每种划分下都有左部分的最大值和右部分的最大值，请返回最大的， 左部分最大值减去右部分最大值的绝对值。</p><p><strong>输入描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行输入一个整数N(N&lt;100000)</span><br><span class="line">第二行输入N个整数表示arr</span><br></pre></td></tr></table></figure><p><strong>输出描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出左部分最大值减去右部分最大值的绝对值的最大值</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:arr)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,x);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;(ans-<span class="built_in">min</span>(arr[<span class="number">0</span>],arr[n<span class="number">-1</span>]))&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11最难的问题"><a href="#11最难的问题" class="headerlink" title="11最难的问题"></a>11<a href="https://www.nowcoder.com/questionTerminal/9f6b8f6ec26d44cfb8fc8c664b0edb6b">最难的问题</a></h3><p>NowCoder生活在充满危险和阴谋的年代。为了生存，他首次发明了密码，用于军队的消息传递。假设你是军团中的一名军官，需要把发送来的消息破译出来、并提<br>供给你的将军。<br>消息加密的办法是：对消息原文中的每个字母，分别用该字母之后的第5个字母替换（例如：消息原文中的每个字母A 都分别替换成字母F），<br>其他字符不 变，并且消息原文的所有字母都是大写的。密码中的字母与原文中的字母对应关系如下。<br>密码字母：A B C D E F G H I J K L M N O P Q R S T U V W X Y Z<br>原文字母：V W X Y Z A B C D E F G H I J K L M N O P Q R S T U</p><p><strong>输入描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入包括多组数据，每组数据一行，为收到的密文。</span><br><span class="line">密文仅有空格和大写字母组成。</span><br></pre></td></tr></table></figure><p><strong>输出描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对应每一组数据，输出解密后的明文。</span><br></pre></td></tr></table></figure><p>密码 &gt; ‘E’<br>则：原文&#x3D; 密码 - 5<br>否则： 原文 &#x3D; 密码 + 21</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c = <span class="built_in">getchar</span>()) != EOF) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; <span class="string">&#x27;Z&#x27;</span> &gt;= c) &#123;</span><br><span class="line">            c = (c &gt; <span class="string">&#x27;E&#x27;</span>) ? (c - <span class="number">5</span>) : (c + <span class="number">21</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12天使果冻"><a href="#12天使果冻" class="headerlink" title="12天使果冻"></a>12<a href="https://ac.nowcoder.com/acm/contest/11161/A">天使果冻</a></h3><p><strong>题目描述</strong><br>有 n 个果冻排成一排。第 i 个果冻的美味度是 𝑎𝑖<br>天使非常喜欢吃果冻，但她想把最好吃的果冻留到最后收藏。<br>天使想知道前 x 个果冻中，美味度第二大的果冻有多少美味度？<br>一共有 𝑞 次询问。<br>注：如果最大的数有两个以上，默认第二大的等于最大的。例如，<br>[2,3,4,2,4]  这个序列，第二大的数是4。</p><p><strong>输入描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一行一个正整数 𝑛 第二行 n 个正整数 𝑎𝑖 ，用空格隔开。</span><br><span class="line">第三行一个正整数 q 。</span><br><span class="line">接下来的 q 行，每行一个正整数 x ，代表一次询问。</span><br><span class="line">数据范围：1≤q≤1e5，1≤ai≤1e9，2≤x≤n≤1e5</span><br></pre></td></tr></table></figure><p><strong>输出描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出 𝑞 行，每行一个正整数，代表一次询问，输出前</span><br><span class="line">x 个果冻中美味度第二大的值。</span><br></pre></td></tr></table></figure><p>不采取排序的方式 如果数组过大 程序会超时</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">first_max</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">second_max</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预处理每个前缀的最大值和次大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; first_max[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            second_max[i] = first_max[i - <span class="number">1</span>];</span><br><span class="line">            first_max[i] = a[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &gt; second_max[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            second_max[i] = a[i];</span><br><span class="line">            first_max[i] = first_max[i - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            first_max[i] = first_max[i - <span class="number">1</span>];</span><br><span class="line">            second_max[i] = second_max[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        cout &lt;&lt; second_max[x] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13dd爱旋转"><a href="#13dd爱旋转" class="headerlink" title="13dd爱旋转"></a>13<a href="https://ac.nowcoder.com/acm/contest/11211/E">dd爱旋转</a></h3><p><strong>题目描述</strong></p><p>读入一个<br>n∗n的矩阵，对于一个矩阵有以下两种操作<br>1:顺时针旋 180°<br>2:关于行镜像<br>如</p><img src="/2024/08/17/Regular-questions/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240820104956.png" class=""><p>给出 q个操作，输出操作完的矩阵</p><p><strong>输入描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一行一个数n(1≤n≤1000)，表示矩阵大小</span><br><span class="line">接下来n行，每行n个数，描述矩阵，其中数字范围为[1,2000]</span><br><span class="line">一下来一行一个数q(1≤q≤100000)，表示询问次数</span><br><span class="line">接下来q行，每行一个数x(x=1或x=2)，描述每次询问</span><br></pre></td></tr></table></figure><p><strong>输出描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n行，每行n个数，描述操作后的矩阵</span><br></pre></td></tr></table></figure><p>简单模拟即可<br>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 矩阵旋转180度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate180</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;matrix, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(matrix[i][j], matrix[n - <span class="number">1</span> - i][n - <span class="number">1</span> - j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n / <span class="number">2</span>; ++j) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(matrix[n / <span class="number">2</span>][j], matrix[n / <span class="number">2</span>][n - <span class="number">1</span> - j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩阵关于行镜像</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mirrorRows</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;matrix, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(matrix[i], matrix[n - <span class="number">1</span> - i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrix</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="type">int</span> rotate180_count = <span class="number">0</span>, mirror_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">            rotate180_count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">2</span>) &#123;</span><br><span class="line">            mirror_count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 奇数次的旋转180度</span></span><br><span class="line">    <span class="keyword">if</span> (rotate180_count % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">rotate180</span>(matrix, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 奇数次的行镜像</span></span><br><span class="line">    <span class="keyword">if</span> (mirror_count % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">mirrorRows</span>(matrix, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出最终矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            cout &lt;&lt; matrix[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14因子个数"><a href="#14因子个数" class="headerlink" title="14因子个数"></a>14<a href="https://www.nowcoder.com/questionTerminal/e8fb8f89f5d147ec92fd8ecfefe89b0d">因子个数</a></h3><p>一个正整数可以分解成一个或多个数组的积。例如36&#x3D;2<em>2</em>3*3，即包含2和3两个因子。<br>NowCoder最近在研究因子个数的分布规律，现在给出一系列正整数，他希望你开发一个程序输出每个正整数的因子个数。</p><p><strong>输入描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入包括多组数据。</span><br><span class="line">每组数据仅有一个整数n (2≤n≤100000)。</span><br></pre></td></tr></table></figure><p><strong>输出描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对应每个整数，输出其因子个数，每个结果占一行。</span><br></pre></td></tr></table></figure><p>思路:<br>从最小因子2到数字的最大因子数（数字的平方根）开始判断是否能够取余<br>可以 则循环取余直到取余不为0，因子个数+1;否则使用下一个因子计算；<br>最终整除了各个因子数之后剩余的数字不为1则本身也是一个因子，因此因子数+1<br>注意：因子个数 而不是 一共有几个因子</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">                    n/=i;</span><br><span class="line">                &#125;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n!=<span class="number">1</span>) k++;</span><br><span class="line">        cout&lt;&lt;k&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14分解因子"><a href="#14分解因子" class="headerlink" title="14分解因子"></a>14<a href="https://www.nowcoder.com/questionTerminal/0f6976af36324f8bab1ea61e9e826ef5">分解因子</a></h3><p>所谓因子分解，就是把给定的正整数a，分解成若干个素数的乘积，即 a &#x3D; a1 × a2 × a3 × … × an,<br>并且 1 &lt; a1 ≤ a2 ≤ a3 ≤ … ≤ an。其中a1、a2、…、an均为素数。 先给出一个整数a，请输出分解后的因子。</p><p><strong>输入描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入包含多组数据，每组数据包含一个正整数a（2≤a≤1000000）。</span><br></pre></td></tr></table></figure><p><strong>输出描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对应每组数据，以“a = a1 * a2 * a3...”的形式输出因式分解后的结果。</span><br></pre></td></tr></table></figure><p>简单素数判断 </p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 函数：分解素因子</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">primeFactorization</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; <span class="string">&quot; = &quot;</span>;</span><br><span class="line">    <span class="type">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!first) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot; * &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; i;</span><br><span class="line">            n /= i;</span><br><span class="line">            first = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 n 仍然大于 1，那么它本身就是一个素数</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!first) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; * &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; n;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; a) &#123;</span><br><span class="line">        <span class="built_in">primeFactorization</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15剪花布条"><a href="#15剪花布条" class="headerlink" title="15剪花布条"></a>15<a href="https://www.nowcoder.com/practice/1046cd038f7a4b04b2b77b415973de1c?tpId=3&tqId=10919&qru=/ta/hackathon/question-ranking">剪花布条</a></h3><p><strong>描述</strong></p><p>一块花布条，里面有些图案，另有一块直接可用的小饰条，里面也有一些图案。<br>对于给定的花布条和小饰条，计算一下能从花布条中尽可能剪出几块小饰条来呢？</p><p><strong>输入描述：</strong><br>输入包含多组数据。<br>每组数据包含两个字符串s,t，分别是成对出现的花布条和小饰条，其布条都是用可见ASCII字符表示的，<br>可见的ASCII字符有多少个，布条的花纹也有多少种花样。花纹条和小饰条不会超过1000个字符长。</p><p><strong>输出描述：</strong></p><p>对应每组输入，输出能从花纹布中剪出的最多小饰条个数，如果一块都没有，那就输出0，每个结果占一行。</p><p>字符查找 str.find</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="type">const</span> string&amp; s,<span class="type">const</span> string&amp; t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((pos=s.<span class="built_in">find</span>(t,pos))!=string::npos)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        pos+=t.<span class="built_in">length</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s,t;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;s&gt;&gt;t)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">countSubstrings</span>(s,t)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16收件人列表"><a href="#16收件人列表" class="headerlink" title="16收件人列表"></a>16<a href="https://www.nowcoder.com/practice/5973a31d58234b068fa1fe34f7290855?qru=/ta/hackathon/question-ranking">收件人列表</a></h3><p><strong>描述</strong></p><p>NowCoder每天要给许多客户写电子邮件。正如你所知，如果一封邮件中包含多个收件人，<br>收件人姓名之间会用一个逗号和空格隔开；如果收件人姓名也包含空格或逗号，则姓名需要用双引号包含。<br>现在给你一组收件人姓名，请你帮他生成相应的收件人列表。</p><p><strong>输入描述：</strong></p><p>输入包含多组数据。<br>每组数据的第一行是一个整数n (1≤n≤128)，表示后面有n个姓名。<br>紧接着n行，每一行包含一个收件人的姓名。姓名长度不超过16个字符。</p><p><strong>输出描述：</strong></p><p>对应每一组输入，输出一行收件人列表。</p><p>字符串查找对应的字符</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="built_in">getchar</span>();<span class="comment">//数字后面有个换行符不要忘了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">getline</span>(cin, str);</span><br><span class="line">            <span class="keyword">if</span> (str.<span class="built_in">find</span>(<span class="string">&#x27; &#x27;</span>) != str.npos || str.<span class="built_in">find</span>(<span class="string">&#x27;,&#x27;</span>) != str.npos)</span><br><span class="line">                cout &lt;&lt; <span class="string">&#x27;&quot;&#x27;</span> &lt;&lt; str &lt;&lt; <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; str;</span><br><span class="line">            (i + <span class="number">1</span> != n) ? cout &lt;&lt; <span class="string">&quot;, &quot;</span> : cout &lt;&lt; endl; <span class="comment">//最后一个不用输出逗号空格按要求输出换行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17抄送列表"><a href="#17抄送列表" class="headerlink" title="17抄送列表"></a>17<a href="https://www.nowcoder.com/questionTerminal/286af664b17243deb745f69138f8a800">抄送列表</a></h3><p>NowCoder每天要处理许多邮件，但他并不是在收件人列表中，有时候只是被抄送。<br>他认为这些抄送的邮件重要性比自己在收件人列表里的邮件低，因此他要过滤掉这些次要的邮件，优先处理重要的邮件。<br>现在给你一串抄送列表，请你判断目标用户是否在抄送列表中。</p><p><strong>输入描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入有多组数据，每组数据有两行。</span><br><span class="line">第一行抄送列表，姓名之间用一个逗号隔开。如果姓名中包含空格或逗号，</span><br><span class="line">则姓名包含在双引号里。总长度不超过512个字符。</span><br><span class="line">第二行只包含一个姓名，是待查找的用户的名字（姓名要完全匹配）。长度不超过16个字符。</span><br></pre></td></tr></table></figure><p><strong>输出描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果第二行的名字出现在收件人列表中，则输出“Ignore”，表示这封邮件不重要；</span><br><span class="line">否则，输出“Important!”，表示这封邮件需要被优先处理。</span><br></pre></td></tr></table></figure><p>截取字符串 substr</p><ol><li>通过getiine(cin, names)方法获取第一行中的所有名字</li><li>解析出第一行中的所有名字保存在unordered_set中</li><li>获取第二行中的名字，检测该名字是否存在，并按照题目的要求进行输出</li></ol><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(cin,name))&#123;</span><br><span class="line">        unordered_set&lt;string&gt; set;</span><br><span class="line">        <span class="type">size_t</span> pos=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos&lt;name.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(name[pos]==<span class="string">&#x27;\&quot;&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//名字中包含&quot;&quot;</span></span><br><span class="line">                <span class="type">size_t</span> end=name.<span class="built_in">find</span>(<span class="string">&#x27;\&quot;&#x27;</span>,pos+<span class="number">1</span>);</span><br><span class="line">                set.<span class="built_in">insert</span>(name.<span class="built_in">substr</span>(pos+<span class="number">1</span>,end-pos<span class="number">-1</span>));</span><br><span class="line">                pos=end+<span class="number">2</span>;<span class="comment">//跳过&quot;&quot;和,</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">size_t</span> end=name.<span class="built_in">find</span>(<span class="string">&#x27;,&#x27;</span>,pos);</span><br><span class="line">                <span class="keyword">if</span>(end==<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="comment">//最后一个名字</span></span><br><span class="line">                    set.<span class="built_in">insert</span>(name.<span class="built_in">substr</span>(pos));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                set.<span class="built_in">insert</span>(name.<span class="built_in">substr</span>(pos,end-pos));</span><br><span class="line">                pos=end+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//接受第二个名字</span></span><br><span class="line">        <span class="built_in">getline</span>(cin,name);</span><br><span class="line">        <span class="keyword">if</span>(set.<span class="built_in">find</span>(name)==set.<span class="built_in">end</span>())&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Important!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Ignore&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18养兔子"><a href="#18养兔子" class="headerlink" title="18养兔子"></a>18<a href="https://www.nowcoder.com/questionTerminal/71d3849a19f04a1591c415964ac148f1">养兔子</a></h3><p>一只成熟的兔子每天能产下一胎兔子。每只小兔子的成熟期是一天。 某人领养了一只小兔子，请问第N天以后，他将会得到多少只兔子。</p><p><strong>输入描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">测试数据包括多组，每组一行，为整数n(1≤n≤90)。</span><br></pre></td></tr></table></figure><p><strong>输出描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对应输出第n天有几只兔子(假设没有兔子死亡现象)。</span><br></pre></td></tr></table></figure><p>斐波那契数列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n[<span class="number">91</span>] = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">90</span>; i++) &#123;</span><br><span class="line">        n[i] = n[i - <span class="number">1</span>] + n[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">    <span class="keyword">while</span> (std::cin &gt;&gt; d) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, n[d - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19mkdir"><a href="#19mkdir" class="headerlink" title="19mkdir"></a>19<a href="https://www.nowcoder.com/practice/433c0c6a1e604a4795291d9cd7a60c7a?tpId=3&tags=&title=&diffculty=0&judgeStatus=0">mkdir</a></h3><p><strong>描述</strong><br>工作中，每当要部署一台新机器的时候，就意味着有一堆目录需要创建。<br>例如要创建目录“&#x2F;usr&#x2F;local&#x2F;bin”，就需要此次创建“&#x2F;usr”、“&#x2F;usr&#x2F;local”以及“&#x2F;usr&#x2F;local&#x2F;bin”。<br>好在，Linux下mkdir提供了强大的“-p”选项，只要一条命令“mkdir -p &#x2F;usr&#x2F;local&#x2F;bin”就能自动创建需要的上级目录。<br>现在给你一些需要创建的文件夹目录，请你帮忙生成相应的“mkdir -p”命令。</p><p><strong>输入描述：</strong></p><p>输入包含多组数据。<br>每组数据第一行为一个正整数n(1≤n≤1024)。<br>紧接着n行，每行包含一个待创建的目录名，目录名仅由数字和字母组成，长度不超过200个字符。</p><p><strong>输出描述：</strong></p><p>对应每一组数据，输出相应的、按照字典顺序排序的“mkdir -p”命令。<br>每组数据之后输出一个空行作为分隔。</p><p>判断字符串是否相等，字串问题</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">path</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;path[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">flag</span><span class="params">(n,<span class="literal">true</span>)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(path.<span class="built_in">begin</span>(),path.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//判断两个路径是否相等</span></span><br><span class="line">            <span class="keyword">if</span>(path[i]==path[i+<span class="number">1</span>])&#123;</span><br><span class="line">                flag[i]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断两个路径是否是字串关系</span></span><br><span class="line">            <span class="keyword">if</span>(path[i+<span class="number">1</span>].<span class="built_in">length</span>()&gt;path[i].<span class="built_in">length</span>()&amp;&amp;path[i+<span class="number">1</span>].<span class="built_in">substr</span>(<span class="number">0</span>,path[i].<span class="built_in">length</span>())==path[i]&amp;&amp;path[i+<span class="number">1</span>][path[i].<span class="built_in">length</span>()]==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">                flag[i]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[i])&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;mkdir -p &quot;</span>&lt;&lt;path[i]&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20找出字符串中第一个只出现一次的字符"><a href="#20找出字符串中第一个只出现一次的字符" class="headerlink" title="20找出字符串中第一个只出现一次的字符"></a>20<a href="https://www.nowcoder.com/practice/e896d0f82f1246a3aa7b232ce38029d4?tpId=37&&tqId=21282&qru=/ta/huawei/question-ranking">找出字符串中第一个只出现一次的字符</a></h3><p><strong>描述</strong></p><p>找出字符串中第一个只出现一次的字符<br>数据范围：输入的字符串长度满足 1≤n≤1000</p><p><strong>输入描述：</strong></p><p>输入一个非空字符串</p><p><strong>输出描述：</strong></p><p>输出第一个只出现一次的字符，如果不存在输出-1</p><p>注意是字符(256)而不是字母(26)</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">getFirstOneChar</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> hash[<span class="number">256</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : str) &#123;</span><br><span class="line">        hash[ch]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hash[ch] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    <span class="type">char</span> res=<span class="built_in">getFirstOneChar</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(res==<span class="number">-1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="21微信红包"><a href="#21微信红包" class="headerlink" title="21微信红包"></a>21<a href="https://www.nowcoder.com/practice/fbcf95ed620f42a88be24eb2cd57ec54?tpId=49&&tqId=29311&qru=/ta/2016test/question-ranking">微信红包</a></h3><p><strong>描述</strong></p><p>春节期间小明使用微信收到很多个红包，非常开心。在查看领取红包记录时发现，某个红包金额出现的次数超过了红包总数的一半。<br>请帮小明找到该红包金额。写出具体算法思路和代码实现，要求算法尽可能高效。<br>给定一个红包的金额数组 gifts 及它的大小 n ，请返回所求红包的金额。<br>若没有金额超过总数的一半，返回0。<br>数据范围：1≤n≤1000 ,红包金额满足 1≤gift≤100000 </p><p>超过数组一半的元素-&gt;如果存在，一定在数组正中间</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Gift</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">(vector&lt;<span class="type">int</span>&gt; gifts, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="type">int</span> middle = n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : gifts) &#123;</span><br><span class="line">            map[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : map) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.second &gt; middle) &#123;</span><br><span class="line">                <span class="keyword">return</span> x.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="22猴子分桃"><a href="#22猴子分桃" class="headerlink" title="22猴子分桃"></a>22<a href="https://www.nowcoder.com/practice/480d2b484e1f43af8ea8434770811b4a">猴子分桃</a></h3><p><strong>描述</strong></p><p>老猴子辛苦了一辈子，给那群小猴子们留下了一笔巨大的财富——一大堆桃子。老猴子决定把这些桃子分给小猴子。<br>第一个猴子来了，它把桃子分成五堆，五堆一样多，但还多出一个。它把剩下的一个留给老猴子，自己拿走其中的一堆。<br>第二个猴子来了，它把桃子分成五堆，五堆一样多，但又多出一个。它把多出的一个留给老猴子，自己拿走其中的一堆。<br>后来的小猴子都如此照办。最后剩下的桃子全部留给老猴子。<br>这里有n只小猴子，请你写个程序计算一下在开始时至少有多少个桃子，以及最后老猴子最少能得到几个桃子。</p><p><strong>输入描述：</strong></p><p>输入包括多组测试数据。<br>每组测试数据包括一个整数n(1≤n≤20)。<br>输入以0结束，该行不做处理。</p><p><strong>输出描述：</strong></p><p>每组测试数据对应一行输出。<br>包括两个整数a，b。<br>分别代表开始时最小需要的桃子数，和结束后老猴子最少能得到的桃子数。</p><p>数学分析题：<br>因为每次分5堆都会多出来1个，所以我们借给猴子们4个，以致每次都可以刚好分成5堆<br>并且，每次给老猴子的桃 子都不在我们借出的那4个中，这样最后减掉4就可以得到结果。<br>假设最初由x个桃子，我们借给猴子4个，则此时 有x+4个，<br>第一个猴子得到（x+4）&#x2F;5，剩余（x+4）（4&#x2F;5）个<br>第二个猴子分完后剩余（x+4） (4&#x2F;5)^2个<br>第三个 猴子分完后剩余（x+4） (4&#x2F;5)^3个<br>依次类推，第n个猴子分完后剩余（x+4）（4&#x2F;5）^n 要满足最后剩余的为整数，<br>并且x最小，则当 x+4&#x3D;5^n时，满足要求；此时，x&#x3D;5^n - 4;<br>老猴子得到的数量为：（x+4）*（4&#x2F;5）^n + n - 4 &#x3D; 4^n + n - 4<br>最后的 +n是因为每个小猴子都会多出一个给老猴子，-4是还了借的4个</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">long</span> total=<span class="built_in">pow</span>(<span class="number">5</span>,n)<span class="number">-4</span>;</span><br><span class="line">        <span class="type">long</span> left=<span class="built_in">pow</span>(<span class="number">4</span>,n)+n<span class="number">-4</span>;</span><br><span class="line">        cout&lt;&lt;total&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;left&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23游游的字母串"><a href="#23游游的字母串" class="headerlink" title="23游游的字母串"></a>23<a href="https://www.nowcoder.com/questionTerminal/785df7fc0eea4ee4b1bfa47f12bfc80a">游游的字母串</a></h3><p>对于一个小写字母而言，游游可以通过一次操作把这个字母变成相邻的字母。<br>‘a’和’b’相邻，’b’和’c’相邻，以此类推。特殊的，’a’和’z’也是相邻的。可以认为， 小写字母的相邻规则为一个环。<br>游游拿到了一个仅包含小写字母的字符串，她想知道，使得所有字母都相等至少要多少次操作？</p><p><strong>输入描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个仅包含小写字母，长度不超过100000的字符串。</span><br></pre></td></tr></table></figure><p><strong>输出描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个整数，代表最小的操作次数。</span><br></pre></td></tr></table></figure><p>思路：<br>26个字母依次进行枚举</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> i = <span class="string">&#x27;a&#x27;</span>; i &lt;= <span class="string">&#x27;z&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            sum += <span class="built_in">min</span>(<span class="built_in">abs</span>(s[j] - i), <span class="number">26</span> - <span class="built_in">abs</span>(s[j] - i)); <span class="comment">//从左去或从右去</span></span><br><span class="line">        &#125;</span><br><span class="line">        cnt = <span class="built_in">min</span>(cnt, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="24合唱队形"><a href="#24合唱队形" class="headerlink" title="24合唱队形"></a>24<a href="https://www.nowcoder.com/practice/cf209ca9ac994015b8caf5bf2cae5c98?tpId=61&tqId=29545&qru=/ta/pku-kaoyan/question-ranking">合唱队形</a></h3><p><strong>描述</strong></p><p>N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学不交换位置就能排成合唱队形。<br>合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1, 2, …, K，他们的身高分别为T1, T2, …, TK，<br>则他们的身高满足T1 &lt; T2 &lt; … &lt; Ti , Ti &gt; Ti+1 &gt; … &gt; TK (1 &lt;&#x3D; i &lt;&#x3D; K)。<br>你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。</p><p><strong>输入描述：</strong></p><p>输入的第一行是一个整数N（2 &lt;&#x3D; N &lt;&#x3D; 100），表示同学的总数。 第一行有n个整数，用空格分隔，第i个整数Ti（130 &lt;&#x3D; Ti &lt;&#x3D; 230）是第i位同学的身高（厘米）。</p><p><strong>输出描述：</strong></p><p>可能包括多组测试数据，对于每组数据， 输出包括一行，这一行只包含一个整数，就是最少需要几位同学出列。</p><p>思考:</p><p>左侧递增子序列：计算每个位置 i，以该位置为结尾的最长递增子序列的长度。<br>右侧递减子序列：计算每个位置 i，以该位置为起点的最长递减子序列的长度。<br>然后对于每个位置 i，我们计算出当 i 是峰顶时的合唱队形长度，<br>即 left[i] + right[i] - 1，最后取最大的长度，再用 N 减去这个长度即可得到最少需要出列的同学人数。</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minStudentsToRemove</span><span class="params">(<span class="type">int</span> N, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(N, <span class="number">1</span>)</span></span>;  <span class="comment">// 记录左侧递增子序列的长度</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(N, <span class="number">1</span>)</span></span>; <span class="comment">// 记录右侧递减子序列的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算左侧递增子序列的长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heights[i] &gt; heights[j]) &#123;</span><br><span class="line">                left[i] = <span class="built_in">max</span>(left[i], left[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算右侧递减子序列的长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = N - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = N - <span class="number">1</span>; j &gt; i; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heights[i] &gt; heights[j]) &#123;</span><br><span class="line">                right[i] = <span class="built_in">max</span>(right[i], right[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算最长的合唱队形的长度</span></span><br><span class="line">    <span class="type">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        maxLength = <span class="built_in">max</span>(maxLength, left[i] + right[i] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要移除的同学数量</span></span><br><span class="line">    <span class="keyword">return</span> N - maxLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; N) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">heights</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; heights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">minStudentsToRemove</span>(N, heights) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="25另类加法"><a href="#25另类加法" class="headerlink" title="25另类加法"></a>25<a href="https://www.nowcoder.com/practice/e7e0d226f1e84ba7ab8b28efc6e1aebc">另类加法</a></h3><p><strong>描述</strong></p><p>给定两个int A和B。编写一个函数返回A+B的值，但不得使用+或其他算数运算符。</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnusualAdd</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">addAB</span><span class="params">(<span class="type">int</span> A, <span class="type">int</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(A==<span class="number">0</span>) <span class="keyword">return</span> B;</span><br><span class="line">        <span class="keyword">if</span>(B==<span class="number">0</span>) <span class="keyword">return</span> A;</span><br><span class="line">        <span class="type">int</span> a=A^B;</span><br><span class="line">        <span class="type">int</span> b=(A&amp;B)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">addAB</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="26井字棋"><a href="#26井字棋" class="headerlink" title="26井字棋"></a>26<a href="https://www.nowcoder.com/practice/e1bb714eb9924188a0d5a6df2216a3d1?tpId=8&&tqId=11055&qru=/ta/cracking-the-coding-interview/question-ranking">井字棋</a></h3><p><strong>描述</strong></p><p>给定一个二维数组board，代表棋盘，其中元素为1的代表是当前玩家的棋子，0表示没有棋子，-1代表是对方玩家的棋子。<br>当一方棋子在横竖斜方向上有连成排的及获胜（及井字棋规则），返回当前玩家是否胜出。</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Board</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkWon</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; board)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">bool</span> winMainDiag=<span class="literal">true</span>,winAntiDiag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">bool</span> winRow=<span class="literal">true</span>,winCol=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]!=<span class="number">1</span>) winRow=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(board[j][i]!=<span class="number">1</span>) winCol=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(winRow||winCol) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[i][i]!=<span class="number">1</span>) winMainDiag=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[i][n-i<span class="number">-1</span>]!=<span class="number">1</span>) winAntiDiag=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> winMainDiag||winAntiDiag;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="27密码强度等级"><a href="#27密码强度等级" class="headerlink" title="27密码强度等级"></a>27<a href="https://www.nowcoder.com/practice/52d382c2a7164767bca2064c1c9d5361?tpId=37&tqId=21310&qru=/exam/oj/ta&sourceUrl=/exam/oj/ta?page=2&tpId=37&type=37&difficulty=undefined&judgeStatus=undefined&tags=&title=">密码强度等级</a></h3><p><strong>描述</strong></p><p>密码按如下规则进行计分，并根据不同的得分为密码进行安全等级划分。</p><p>一、密码长度:<br>5 分: 小于等于4 个字符<br>10 分: 5 到7 字符<br>25 分: 大于等于8 个字符</p><p>二、字母:<br>0 分: 没有字母<br>10 分: 密码里的字母全都是小（大）写字母<br>20 分: 密码里的字母符合”大小写混合“</p><p>三、数字:<br>0 分: 没有数字<br>10 分: 1 个数字<br>20 分: 大于1 个数字</p><p>四、符号:<br>0 分: 没有符号<br>10 分: 1 个符号<br>25 分: 大于1 个符号</p><p>五、奖励（只能选符合最多的那一种奖励）:<br>2 分: 字母和数字<br>3 分: 字母、数字和符号<br>5 分: 大小写字母、数字和符号</p><p>最后的评分标准:</p><blockquote><p>&#x3D; 90: 非常安全<br>&#x3D; 80: 安全（Secure）<br>&#x3D; 70: 非常强<br>&#x3D; 60: 强（Strong）<br>&#x3D; 50: 一般（Average）<br>&#x3D; 25: 弱（Weak）<br>&#x3D; 0:  非常弱（Very_Weak）</p></blockquote><p>对应输出为：</p><p>VERY_SECURE<br>SECURE<br>VERY_STRONG<br>STRONG<br>AVERAGE<br>WEAK<br>VERY_WEAK</p><p>请根据输入的密码字符串，进行安全评定。</p><p>注：<br>字母：a-z, A-Z<br>数字：0-9<br>符号包含如下： (ASCII码表可以在UltraEdit的菜单view-&gt;ASCII Table查看)<br>!”#$%&amp;’()*+,-.&#x2F;     (ASCII码：0x21<del>0x2F)<br>:;&lt;&#x3D;&gt;?@             (ASCII码：0x3A</del>0x40)<br>[]^_&#96;              (ASCII码：0x5B<del>0x60)<br>{|}</del>                (ASCII码：0x7B~0x7E)</p><p>提示:<br>1 &lt;&#x3D; 字符串的长度&lt;&#x3D; 300</p><p><strong>输入描述：</strong></p><p>输入一个string的密码</p><p><strong>输出描述：</strong></p><p>输出密码等级</p><p>判断是否是字符 ispunct</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getLengthScore</span><span class="params">(<span class="type">const</span> string&amp; password)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = password.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">4</span>) <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">7</span>) <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">25</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getLetterScore</span><span class="params">(<span class="type">const</span> string&amp; password)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> hasLower = <span class="literal">false</span>, hasUpper = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : password) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">islower</span>(ch)) hasLower = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isupper</span>(ch)) hasUpper = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasLower &amp;&amp; hasUpper) <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">if</span> (hasLower || hasUpper) <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getDigitScore</span><span class="params">(<span class="type">const</span> string&amp; password)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> digitcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : password) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(ch)) digitcount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (digitcount == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (digitcount &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSymbolScore</span><span class="params">(<span class="type">const</span> string&amp; password)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> symbolcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : password) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ispunct</span>(ch)) symbolcount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (symbolcount == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (symbolcount &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getBonusScore</span><span class="params">(<span class="type">const</span> string&amp; password)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> hasLower = <span class="literal">false</span>, hasUpper = <span class="literal">false</span>, hasDigit = <span class="literal">false</span>, hasSymbol = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : password) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">islower</span>(ch)) hasLower = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isupper</span>(ch)) hasUpper = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(ch)) hasDigit = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ispunct</span>(ch)) hasSymbol = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasLower &amp;&amp; hasUpper &amp;&amp; hasDigit &amp;&amp; hasSymbol) <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> ((hasLower || hasUpper) &amp;&amp; hasDigit &amp;&amp; hasSymbol) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> ((hasLower || hasUpper) &amp;&amp; hasDigit) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">getPasswordStrength</span><span class="params">(<span class="type">int</span> score)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (score &gt;= <span class="number">90</span>) <span class="keyword">return</span> <span class="string">&quot;VERY_SECURE&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (score &gt;= <span class="number">80</span>) <span class="keyword">return</span> <span class="string">&quot;SECURE&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (score &gt;= <span class="number">70</span>) <span class="keyword">return</span> <span class="string">&quot;VERY_STRONG&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (score &gt;= <span class="number">60</span>) <span class="keyword">return</span> <span class="string">&quot;STRONG&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (score &gt;= <span class="number">50</span>) <span class="keyword">return</span> <span class="string">&quot;AVERAGE&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (score &gt;= <span class="number">25</span>) <span class="keyword">return</span> <span class="string">&quot;WEAK&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;VERY_WEAK&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string password;</span><br><span class="line">    cin &gt;&gt; password;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">    score += <span class="built_in">getLengthScore</span>(password);</span><br><span class="line">    score += <span class="built_in">getLetterScore</span>(password);</span><br><span class="line">    score += <span class="built_in">getDigitScore</span>(password);</span><br><span class="line">    score += <span class="built_in">getSymbolScore</span>(password);</span><br><span class="line">    score += <span class="built_in">getBonusScore</span>(password);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">getPasswordStrength</span>(score) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="28求最大连续bit数"><a href="#28求最大连续bit数" class="headerlink" title="28求最大连续bit数"></a>28<a href="https://www.nowcoder.com/practice/4b1658fd8ffb4217bc3b7e85a38cfaf2?tpId=37&&tqId=21309&qru=/ta/huawei/question-ranking">求最大连续bit数</a></h3><p><strong>描述</strong></p><p>求一个int类型数字对应的二进制数字中1的最大连续数，例如3的二进制为00000011，最大连续2个1</p><p>数据范围：数据组数： 1≤t≤5 ， 1≤n≤500000<br>进阶：时间复杂度： O(logn) ，空间复杂度： O(1)</p><p><strong>输入描述：</strong></p><p>输入一个int类型数字</p><p><strong>输出描述：</strong></p><p>输出转成二进制之后连续1的个数</p><img src="/2024/08/17/Regular-questions/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240822165818.png" class=""><p>求一个二进制数有几个连续的1，用n与n&lt;&lt;1作&amp;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        n=n&amp;(n&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求一个二进制数有几个1，用n与n-1作&amp;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        n=n&amp;(n<span class="number">-1</span>);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="29二进制插入"><a href="#29二进制插入" class="headerlink" title="29二进制插入"></a>29<a href="https://www.nowcoder.com/practice/30c1674ad5694b3f8f0bc2de6f005490?tpId=8&&tqId=11019&qru=/ta/cracking-the-coding-interview/question-ranking">二进制插入</a></h3><p><strong>描述</strong></p><p>给定两个32位整数n和m，同时给定i和j，将m的二进制数位插入到n的二进制的第j到第i位,保证n的第j到第i位均为零，<br>且m的二进制位数小于等于i-j+1，其中二进制的位数从0开始由低到高。</p><p>测试样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1024，19，2，6</span><br><span class="line">返回：1100</span><br></pre></td></tr></table></figure><img src="/2024/08/17/Regular-questions/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240822170239.png" class=""><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinInsert</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">binInsert</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> j, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        m=m&lt;&lt;j;</span><br><span class="line">        <span class="keyword">return</span> n|m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="30查找组成一个偶数最接近的两个素数"><a href="#30查找组成一个偶数最接近的两个素数" class="headerlink" title="30查找组成一个偶数最接近的两个素数"></a>30<a href="https://www.nowcoder.com/practice/f8538f9ae3f1484fb137789dec6eedb9?tpId=37&tqId=21283&ru=/exam/oj">查找组成一个偶数最接近的两个素数</a></h3><p><strong>描述</strong></p><p>任意一个偶数（大于2）都可以由2个素数组成，组成偶数的2个素数有很多种情况，本题目要求输出组成指定偶数的两个素数差值最小的素数对。</p><p>数据范围：输入的数据满足 4≤n≤1000</p><p><strong>输入描述：</strong></p><p>输入一个大于2的偶数</p><p><strong>输出描述：</strong></p><p>从小到大输出两个素数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=num;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> half=n/<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=half;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isPrime</span>(i)&amp;&amp;<span class="built_in">isPrime</span>(n-i))&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;n-i&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="31参数解析"><a href="#31参数解析" class="headerlink" title="31参数解析"></a>31<a href="https://www.nowcoder.com/practice/668603dc307e4ef4bb07bcd0615ea677?tpId=37&&tqId=21297&qru=/ta/huawei/question-ranking">参数解析</a></h3><p><strong>描述</strong></p><p>在命令行输入如下命令：</p><p>xcopy &#x2F;s c:\ d:\e，</p><p>各个参数如下：</p><p>参数1：命令字xcopy</p><p>参数2：字符串&#x2F;s</p><p>参数3：字符串c:\</p><p>参数4: 字符串d:\e</p><p>请编写一个参数解析程序，实现将命令行各个参数解析出来。</p><p>解析规则：</p><p>1.参数分隔符为空格</p><p>2.对于用””包含起来的参数，如果中间有空格，不能解析为多个参数。比如在命令行输入xcopy &#x2F;s “C:\program files” “d:&quot;时，参数仍然是4个，第3个参数应该是字符串C:\program files，而不是C:\program，注意输出参数时，需要将””去掉，引号不存在嵌套情况。</p><p>3.参数不定长</p><p>4.输入由用例保证，不会出现不符合要求的输入</p><p>数据范围：字符串长度： 1≤s≤1000<br>进阶：时间复杂度： O(n) ，空间复杂度： O(n)</p><p><strong>输入描述：</strong></p><p>输入一行字符串，可以有空格</p><p><strong>输出描述：</strong></p><p>输出参数个数，分解后的参数，每个参数都独占一行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cmdLineParse</span><span class="params">(<span class="type">const</span> string&amp; str)</span></span>&#123;</span><br><span class="line">    vector&lt;string&gt; param;</span><br><span class="line">    string tmp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ch:str)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;&quot;&#x27;</span>)&#123;</span><br><span class="line">            flag=!flag;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27; &#x27;</span>&amp;&amp;!flag)&#123;</span><br><span class="line">            param.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            tmp.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            tmp+=ch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!tmp.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        param.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;param.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> s:param)&#123;</span><br><span class="line">        cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="built_in">getline</span>(cin,str);</span><br><span class="line">    <span class="built_in">cmdLineParse</span>(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="32神奇数"><a href="#32神奇数" class="headerlink" title="32神奇数"></a>32<a href="https://www.nowcoder.com/questionTerminal/99fa7be28d5f4a9d9aa3c98a6a5b559a">神奇数</a></h3><p>给出一个区间[a, b]，计算区间内“神奇数”的个数。<br>神奇数的定义：存在不同位置的两个数位，组成一个两位数（且不含前导0），且这个两位数为质数。<br>比如：153，可以使用数字3和数字1组成13，13是质数，满足神奇数。同样153可以找到31和53也为质数，只要找到一个质数即满足神奇数。</p><p><strong>输入描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入为两个整数a和b，代表[a, b]区间 (1 ≤ a ≤ b ≤ 10000)。</span><br></pre></td></tr></table></figure><p><strong>输出描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出为一个整数，表示区间内满足条件的整数个数</span><br></pre></td></tr></table></figure><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=num;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isMagicNumber</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    string str=<span class="built_in">to_string</span>(num);</span><br><span class="line">    <span class="type">int</span> len=str.<span class="built_in">length</span>();</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; set;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;len;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=j)&#123;</span><br><span class="line">                <span class="type">int</span> num=(str[i]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+(str[j]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span>(num&gt;<span class="number">10</span>)&#123;</span><br><span class="line">                    set.<span class="built_in">insert</span>(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:set)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isPrime</span>(x)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a;i&lt;=b;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isMagicNumber</span>(i)) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="33进制转换"><a href="#33进制转换" class="headerlink" title="33进制转换"></a>33<a href="https://www.nowcoder.com/practice/ac61207721a34b74b06597fe6eb67c52?tpId=85&&tqId=29862&qru=/ta/2017test/question-ranking">进制转换</a></h3><p><strong>描述</strong></p><p>给定一个十进制数M，以及需要转换的进制数N。将十进制数M转化为N进制数</p><p><strong>输入描述：</strong></p><p>输入为一行，M(32位整数)、N(2 ≤ N ≤ 16)，以空格隔开。</p><p><strong>输出描述：</strong></p><p>为每个测试实例输出转换后的数，每个输出占一行。如果N大于9，则对应的数字规则参考16进制（比如，10用A表示，等等）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N;</span><br><span class="line">    cin&gt;&gt;M&gt;&gt;N;</span><br><span class="line">    string str=<span class="string">&quot;0123456789ABCDEF&quot;</span>;</span><br><span class="line">    string ans=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(M&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        flag=<span class="literal">true</span>;</span><br><span class="line">        M=-M;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(M==<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(M)&#123;</span><br><span class="line">        ans+=str[M%N];</span><br><span class="line">        M/=N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        ans+=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="34Fibonacci数列"><a href="#34Fibonacci数列" class="headerlink" title="34Fibonacci数列"></a>34<a href="https://www.nowcoder.com/practice/18ecd0ecf5ef4fe9ba3f17f8d00d2d66?tpId=85&&tqId=29846&qru=/ta/2017test/question-ranking">Fibonacci数列</a></h3><p><strong>描述</strong></p><p>Fibonacci数列是这样定义的：<br>F[0] &#x3D; 0<br>F[1] &#x3D; 1<br>for each i ≥ 2: F[i] &#x3D; F[i-1] + F[i-2]<br>因此，Fibonacci数列就形如：0, 1, 1, 2, 3, 5, 8, 13, …，在Fibonacci数列中的数我们称为Fibonacci数。<br>给你一个N，你想让其变为一个Fibonacci数，每一步你可以把当前数字X变为X-1或者X+1，现在给你一个数N求最少需要多少步可以变为Fibonacci数。</p><p><strong>输入描述：</strong></p><p>输入为一个正整数N(1 ≤ N ≤ 1,000,000)</p><p><strong>输出描述：</strong></p><p>输出一个最小的步数变为Fibonacci数”</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> N,f0=<span class="number">0</span>,f1=<span class="number">1</span>,l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> f=f0+f1;</span><br><span class="line">        f0=f1;</span><br><span class="line">        f1=f;</span><br><span class="line">        <span class="keyword">if</span>(f&lt;N)&#123;</span><br><span class="line">            l=N-f;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            r=f-N;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt; <span class="built_in">min</span>(l,r) &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="35两种排序方法"><a href="#35两种排序方法" class="headerlink" title="35两种排序方法"></a>35<a href="https://www.nowcoder.com/practice/839f681bf36c486fbcc5fcb977ffe432?tpId=85&&tqId=29844&qru=/ta/2017test/question-ranking">两种排序方法</a></h3><p><strong>描述</strong></p><p>考拉有n个字符串字符串，任意两个字符串长度都是不同的。考拉最近学习到有两种字符串的排序方法：</p><p>1.根据字符串的字典序排序。例如：<br>“car” &lt; “carriage” &lt; “cats” &lt; “doggies &lt; “koala”</p><p>2.根据字符串的长度排序。例如：<br>“car” &lt; “cats” &lt; “koala” &lt; “doggies” &lt; “carriage”</p><p>考拉想知道自己的这些字符串排列顺序是否满足这两种排序方法，考拉要忙着吃树叶，所以需要你来帮忙验证。</p><p><strong>输入描述：</strong></p><p>输入第一行为字符串个数n(n ≤ 100) 接下来的n行,每行一个字符串,字符串长度均小于100，均由小写字母组成</p><p><strong>输出描述：</strong></p><p>如果这些字符串是根据字典序排列而不是根据长度排列输出”lexicographically”,<br>如果根据长度排列而不是字典序排列输出”lengths”,<br>如果两种方式都符合输出”both”，否则输出”none”</p><p>思路：长度，字典序如何比较  lambda表达式</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; arr_copy=arr;</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">bool</span> lexicographically=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]!=arr_copy[i])&#123;</span><br><span class="line">            lexicographically=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>(),[](<span class="type">const</span> string&amp;str1,<span class="type">const</span> string&amp;str2)&#123;</span><br><span class="line">        <span class="keyword">return</span> str1.<span class="built_in">length</span>()&lt;str2.<span class="built_in">length</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">bool</span> lengths=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]!=arr_copy[i])&#123;</span><br><span class="line">            lengths=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lexicographically&amp;&amp;lengths)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;both&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(lexicographically&amp;&amp;!lengths)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;lexicographically&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!lexicographically&amp;&amp;lengths)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;lengths&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;none&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="36重构字符串"><a href="#36重构字符串" class="headerlink" title="36重构字符串"></a>36<a href="https://leetcode.cn/problems/reorganize-string/description/">重构字符串</a></h3><p>给定一个字符串 s ，检查是否能重新排布其中的字母，使得两相邻的字符不同。</p><p>返回 s 的任意可能的重新排列。若不可行，返回空字符串 “” 。</p><p>思路: m&gt;n−m+1，那么无法重排，返回空字符串;从偶数下标开始填，如果单个字母出现的次数过多，则不能进行重构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reorganizeString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">length</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch:s) mp[ch]++;</span><br><span class="line"></span><br><span class="line">        vector&lt;pair&lt;<span class="type">char</span>,<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(mp.<span class="built_in">begin</span>(),mp.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),[](<span class="type">const</span> <span class="keyword">auto</span>&amp;p,<span class="type">const</span> <span class="keyword">auto</span>&amp;q)&#123;</span><br><span class="line">            <span class="keyword">return</span> p.second&gt;q.second;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> m=v[<span class="number">0</span>].second;</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n-m+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">ans</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>[ch,cnt]:v)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cnt--)&#123;</span><br><span class="line">                ans[i]=ch;</span><br><span class="line">                i+=<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=n)&#123;</span><br><span class="line">                    i=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="37mari和shiny"><a href="#37mari和shiny" class="headerlink" title="37mari和shiny"></a>37<a href="https://ac.nowcoder.com/acm/problem/26226">mari和shiny</a></h3><p><strong>题目描述</strong></p><p>mari每天都非常shiny。她的目标是把正能量传达到世界的每个角落！<br>有一天，她得到了一个仅由小写字母组成的字符串。<br>她想知道，这个字符串有多少个”shy”的子序列？<br>（所谓子序列的含义见样例说明）</p><p><strong>输入描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行一个正整数n，代表字符串的长度。（1≤n≤300000）</span><br><span class="line">第二行为一个长度为n，仅由小写字母组成的字符串。</span><br></pre></td></tr></table></figure><p><strong>输出描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个正整数，代表子序列&quot;shy&quot;的数量。</span><br></pre></td></tr></table></figure><p>需要注意数值的范围</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="type">long</span> <span class="type">long</span> n;</span><br><span class="line">     cin&gt;&gt;n;</span><br><span class="line">     string str;</span><br><span class="line">     cin&gt;&gt;str;</span><br><span class="line">     <span class="type">long</span> <span class="type">long</span> counts=<span class="number">0</span>,countsh=<span class="number">0</span>,countshy=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">auto</span> ch:str)&#123;</span><br><span class="line">         <span class="keyword">if</span>(ch==<span class="string">&#x27;s&#x27;</span>) counts++;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27;h&#x27;</span>) countsh+=counts;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27;y&#x27;</span>) countshy+=countsh;</span><br><span class="line">     &#125;</span><br><span class="line">     cout&lt;&lt;countshy&lt;&lt;endl;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>进阶版本</p><h3 id="38不同的子序列"><a href="#38不同的子序列" class="headerlink" title="38不同的子序列"></a>38<a href="https://leetcode.cn/problems/distinct-subsequences/description/">不同的子序列</a></h3><p>给你两个字符串 s 和 t ，统计并返回在 s 的 子序列 中 t 出现的个数，结果需要对 10^9 + 7 取模。</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">length</span>(),m=t.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">cache</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,<span class="number">-1</span>));<span class="comment">//-1表示没有被访问过</span></span><br><span class="line">        function&lt;<span class="type">long</span> <span class="type">long</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> i,<span class="type">int</span> j)-&gt;<span class="type">long</span> <span class="type">long</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span>&amp; res=cache[i][j];</span><br><span class="line">            <span class="keyword">if</span>(res!=<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==t[j])&#123;</span><br><span class="line">                <span class="keyword">return</span> res=<span class="built_in">dfs</span>(i<span class="number">-1</span>,j<span class="number">-1</span>)+<span class="built_in">dfs</span>(i<span class="number">-1</span>,j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res=<span class="built_in">dfs</span>(i<span class="number">-1</span>,j);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(n<span class="number">-1</span>,m<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="39游游的水果大礼包"><a href="#39游游的水果大礼包" class="headerlink" title="39游游的水果大礼包"></a>39<a href="https://www.nowcoder.com/questionTerminal/3013527b237a48ffbd5640345b616748?answerType=1&f=discussion">游游的水果大礼包</a></h3><p>游游有 n个苹果， m个桃子。她可以把2个苹果和1个桃子组成价值 a元的一号水果大礼包，<br>也可以把1个苹果和2个桃子组成价值 b元的二号水果大礼包。游游想知道，自己最多能组成多少价值总和的大礼包？</p><p><strong>输入描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">四个正整数 n,m,a,b，用空格隔开。分别代表苹果的数量、桃子的数量、一号大礼包价值、二号大礼包价值。</span><br><span class="line">1≤n,m,a,b≤10^6</span><br></pre></td></tr></table></figure><p><strong>输出描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个整数，代表大礼包的最大价值总和。</span><br></pre></td></tr></table></figure><p>贪心算法</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n,m,a,b;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> max_value=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=n/<span class="number">2</span>&amp;&amp;i&lt;=m)&#123;</span><br><span class="line">            <span class="type">int</span> left_n=n<span class="number">-2</span>*i;</span><br><span class="line">            <span class="type">int</span> left_m=m-i;</span><br><span class="line">            <span class="type">int</span> j=<span class="built_in">min</span>(left_n,left_m/<span class="number">2</span>);</span><br><span class="line">            max_value=<span class="built_in">max</span>(max_value,i*a+j*b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;max_value&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="40字符串替换"><a href="#40字符串替换" class="headerlink" title="40字符串替换"></a>40<a href="https://www.nowcoder.com/questionTerminal/f094aed769d84cf3b799033c82fc1bf6?answerType=1&f=discussion">字符串替换</a></h3><p>请你实现一个简单的字符串替换函数。原串中需要替换的占位符为”%s”,请按照参数列表的顺序一一替换占位符。若参数列表的字符数大于占位符个数。则将剩下的参数字符添加到字符串的结尾。</p><p>给定一个字符串A，同时给定它的长度n及参数字符数组arg，请返回替换后的字符串。保证参数个数大于等于占位符个数。保证原串由大小写英文字母组成，同时长度小于等于500。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringFormat</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">formatString</span><span class="params">(string A, <span class="type">int</span> n, vector&lt;<span class="type">char</span>&gt; arg, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> pos=<span class="number">0</span>;</span><br><span class="line">        <span class="type">size_t</span> paramindex=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((pos=A.<span class="built_in">find</span>(<span class="string">&quot;%s&quot;</span>,pos))!=string::npos)&#123;</span><br><span class="line">            <span class="keyword">if</span>(paramindex&lt;arg.<span class="built_in">size</span>())&#123;</span><br><span class="line">                string tmp=<span class="built_in">string</span>(<span class="number">1</span>,arg[paramindex++]);</span><br><span class="line">                A.<span class="built_in">replace</span>(pos,<span class="number">2</span>,tmp);</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(paramindex&lt;arg.<span class="built_in">size</span>())&#123;</span><br><span class="line">            A+=arg[paramindex++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="41洗牌"><a href="#41洗牌" class="headerlink" title="41洗牌"></a>41<a href="https://www.nowcoder.com/practice/5a0a2c7e431e4fbbbb1ff32ac6e8dfa0?tpId=122&tqId=33670">洗牌</a></h3><p><strong>描述</strong></p><p>洗牌在生活中十分常见，现在需要写一个程序模拟洗牌的过程。 现在需要洗2n张牌，从上到下依次是第1张，第2张，第3张一直到第2n张。<br>首先，我们把这2n张牌分成两堆，左手拿着第1张到第n张（上半堆），右手拿着第n+1张到第2n张（下半堆）。接着就开始洗牌的过程，<br>先放下右手的最后一张牌，再放下左手的最后一张牌，接着放下右手的倒数第二张牌，再放下左手的倒数第二张牌，直到最后放下左手的第一张牌。<br>接着把牌合并起来就可以了。 例如有6张牌，最开始牌的序列是1,2,3,4,5,6。首先分成两组，左手拿着1,2,3；右手拿着4,5,6。<br>在洗牌过程中按顺序放下了6,3,5,2,4,1。把这六张牌再次合成一组牌之后，我们按照从上往下的顺序看这组牌，就变成了序列1,4,2,5,3,6。<br>现在给出一个原始牌组，请输出这副牌洗牌k次之后从上往下的序列。</p><p><strong>输入描述：</strong></p><p>第一行一个数T(T ≤ 100)，表示数据组数。对于每组数据，第一行两个数n,k(1 ≤ n,k ≤ 100)，接下来有2n行个数a1,a2,…,a2n(1 ≤ ai ≤ 1000000000)。表示原始牌组从上到下的序列。</p><p><strong>输出描述：</strong></p><p>对于每组数据，输出一行，最终的序列。数字之间用空格隔开，不要在行末输出多余的空格。</p><p>思考:<br>如果当前数小于等于n（即在左手），则他下次出现的位置是 2<em>当前位置<br>与之对应的当前位置小于n（即在右手）的牌,则他下次出现的位置是 2</em>当前位置+1</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> n, k;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cache</span><span class="params">(<span class="number">2</span> * n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;cache[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(cache.begin(), cache.end())</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> m=<span class="number">0</span>;m&lt;n;m++)&#123;</span><br><span class="line">                cache[<span class="number">2</span>*m]=tmp[m];</span><br><span class="line">                cache[<span class="number">2</span>*m+<span class="number">1</span>]=tmp[m+n];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:cache)&#123;</span><br><span class="line">            cout&lt;&lt;x &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="42过桥"><a href="#42过桥" class="headerlink" title="42过桥"></a>42<a href="https://ac.nowcoder.com/acm/contest/11217/F">过桥</a></h3><p><strong>题目描述</strong></p><p>dd被困在了一个迷幻森林，现在她面前有一条凶险的大河，河中央有 n个神奇的浮块，浮块按 1∼n顺序标号，但两两并不相接，第<br>i个浮块上有一个数字 a[i]，可能是正数，也可能是负数,每块浮块都附带一个魔法结界用于传送，当 a[i]为正数时，<br>dd可以选择传送到第 i+k(1≤k≤a[i])个浮块上,当 dd抵达 n号浮块时才可以顺利脱身，显然不管 a[n]是多少，都没有任何意义，当<br>a[i]为负时， dd只能选择标号小于等于[i]的任意一块浮块进行传送，当 i+a[i]&lt;1时，默认只能传送到<br>1的位置，每次传送都会花费 1s的时间，随着时间的流逝，迷雾森林的空气会被逐渐榨干，她现在在<br>1号浮块，她想知道，她最快多久能顺利脱身，如果始终无法逃脱，请输出 −1</p><p><strong>输入描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行一个数n(2≤n≤2000)</span><br><span class="line">接下来一行n个数a[i](1≤|a[i]|≤2000)表示浮块上的数字</span><br></pre></td></tr></table></figure><p><strong>输出描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一行，表示对应的答案</span><br></pre></td></tr></table></figure><p>思路:</p><ul><li>我们从第1个浮块开始，使用BFS逐层遍历每一个浮块。</li><li>对于每一个浮块，计算它可以传送到的其他浮块。</li><li>如果浮块上的数字是正数，我们可以向后传送，最多传送 a[i] 步。</li><li>如果浮块上的数字是负数，我们可以向前传送，最多传送 -a[i] 步。</li><li>传送的目标如果超过范围，按照题意处理。</li><li>BFS的过程中，每传送一次，记录时间 +1。</li><li>如果在BFS过程中到达第 n 个浮块，则输出对应的时间；如果BFS完成后仍未到达，则返回 -1。</li></ul><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;  <span class="comment">// 浮块上的数字</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(n + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;  <span class="comment">// 到达每个浮块的最短时间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);  <span class="comment">// 从第1个浮块开始</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> i = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; <span class="number">0</span>) &#123;  <span class="comment">// 可以向后传送</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= a[i] &amp;&amp; i + k &lt;= n; ++k) &#123;</span><br><span class="line">                <span class="type">int</span> next = i + k;</span><br><span class="line">                <span class="keyword">if</span> (dist[next] == <span class="number">-1</span>) &#123;  <span class="comment">// 未访问过</span></span><br><span class="line">                    dist[next] = dist[i] + <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 可以向前传送</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= -a[i]; ++k) &#123;</span><br><span class="line">                <span class="type">int</span> next = i - k;</span><br><span class="line">                <span class="keyword">if</span> (next &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                    next = <span class="number">1</span>;  <span class="comment">// 传送到第1个浮块</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dist[next] == <span class="number">-1</span>) &#123;  <span class="comment">// 未访问过</span></span><br><span class="line">                    dist[next] = dist[i] + <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dist[n] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="43小红的数字串"><a href="#43小红的数字串" class="headerlink" title="43小红的数字串"></a>43<a href="https://www.nowcoder.com/questionTerminal/d70a5f22b118407f85a88ed7f87ed45c?page=5&onlyReference=false">小红的数字串</a></h3><p>小红拿到了一个数字串（由’1’~’9’组成，不含’0’），她准备截取一段连续子串，使得该子串表示的正整数小于<br>k。你能帮她求出有多少种截取方案吗？</p><p><strong>输入描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行输入一个数字串，长度不超过200000。</span><br><span class="line">第二行输入一个正整数 k。 1≤k≤10^9</span><br></pre></td></tr></table></figure><p><strong>输出描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小于k的截取方案数。</span><br></pre></td></tr></table></figure><p>双指针</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> k;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">            num = num * <span class="number">10</span> + (s[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (num &lt; k) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="44kotori和n皇后"><a href="#44kotori和n皇后" class="headerlink" title="44kotori和n皇后"></a>44<a href="https://ac.nowcoder.com/acm/contest/940/F">kotori和n皇后</a></h3><p><strong>题目描述</strong></p><p>kotori最近在研究n皇后的问题。</p><p>所谓n皇后问题是这样的：一个n*n的地图，上面一共放n个皇后，保证任意两个皇后都不能互相攻击（每个皇后可以攻击同一行、同一列以及同一45度角斜线和135度角斜线上的所有其他皇后）。</p><p>kotori思考了很久都无法得出答案，整个人都变成琴梨了。她于是拿了一堆皇后在一个无穷大的棋盘上模拟，按照次序一共放了k个皇后。</p><p>但是，皇后的站位太复杂了，kotori甚至不知道是否存在两个皇后会互相攻击。于是她想问问聪明的你，在第i个皇后放置在棋盘上之后，是否存在两个皇后可以互相攻击？</p><p><strong>输入描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一行输入一个正整数k，代表总共放置的皇后的个数。（1&lt;=k&lt;=1e5）</span><br><span class="line">接下来的k行，每行两个正整数xi和yi，代表每个皇后的坐标。（1&lt;=xi,yi&lt;=1e9）</span><br><span class="line">之后输入一个正整数t，代表t次询问。（1&lt;=t&lt;=1e5）</span><br><span class="line">接下来的t行，每行一个正整数i，代表询问第i个皇后放置后，是否存在互相攻击的情况。（1&lt;=i&lt;=k）</span><br><span class="line">保证不存在两个皇后放置的位置相同。</span><br></pre></td></tr></table></figure><p><strong>输出描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">共t行。每行对应当前的询问是否存在两个皇后可以互相攻击，若是则输出“Yes”，否则输出“No”</span><br></pre></td></tr></table></figure><p>思考<br>代码逻辑分析<br>初始化四个 unordered_map 来追踪每个皇后所在的行 (row)、列 (col)、45度对角线 (diag1) 和 135度对角线 (diag2)。<br>对于每一个皇后的位置 (x, y)：<br>检查在该皇后所在的行、列或对角线上是否已经有其他皇后。<br>如果检测到冲突（即 row[x], col[y], diag1[x - y], diag2[x + y] 中任一项已经为 true），<br>记录当前的索引 i 为 conflict_index。此后，所有查询只需比较 i 是否大于或等于 conflict_index 即可判断是否存在冲突。<br>对于每个查询 i，如果 i 大于或等于 conflict_index，则输出 “Yes” 表示存在冲突；否则输出 “No”。</p><p>解答</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int k;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;int, bool&gt; row, col, diag1, diag2;</span><br><span class="line">    int conflict_index = -1;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= k; i++) &#123;</span><br><span class="line">        int x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">        if (conflict_index == -1 &amp;&amp; (row[x] || col[y] || diag1[x - y] || diag2[x + y])) &#123;</span><br><span class="line">            conflict_index = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        row[x] = true;</span><br><span class="line">        col[y] = true;</span><br><span class="line">        diag1[x - y] = true;</span><br><span class="line">        diag2[x + y] = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--) &#123;</span><br><span class="line">        int i;</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">        if (conflict_index != -1 &amp;&amp; i &gt;= conflict_index) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="45接雨水"><a href="#45接雨水" class="headerlink" title="45接雨水"></a>45<a href="https://leetcode.cn/problems/trapping-rain-water/description/">接雨水</a></h3><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p>示例</p><img src="/2024/08/17/Regular-questions/rainwatertrap.png" class=""><p>计算每个木桶左右壁的高度 选择最短的木板</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//双向双指针</span></span><br><span class="line">        <span class="comment">//优化</span></span><br><span class="line">        <span class="type">int</span> n=height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> pre_max=<span class="number">0</span>,suf_max=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            pre_max=<span class="built_in">max</span>(pre_max,height[left]);</span><br><span class="line">            suf_max=<span class="built_in">max</span>(suf_max,height[right]);</span><br><span class="line">            <span class="keyword">if</span>(pre_max&gt;suf_max)&#123;</span><br><span class="line">                ans+=suf_max-height[right--];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans+=pre_max-height[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> wildcard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2024/08/17/Dynamic-programming/"/>
      <url>/2024/08/17/Dynamic-programming/</url>
      
        <content type="html"><![CDATA[<p><strong>回溯三问：<br>当前操作是什么?<br>子问题是什么?<br>下一个子问题是什么?</strong></p><h3 id="1合唱团"><a href="#1合唱团" class="headerlink" title="1合唱团"></a>1<a href="https://www.nowcoder.com/practice/661c49118ca241909add3a11c96408c8">合唱团</a></h3><p><strong>描述</strong><br>有 n 个学生站成一排，每个学生有一个能力值，牛牛想从这 n 个学生中按照顺序选取 k 名学生，要求相邻两个学生的位置编号的差不超过 d，使得这 k 个学生的能力值的乘积最大，你能返回最大的乘积吗？</p><p><strong>输入描述：</strong><br>每个输入包含 1 个测试用例。每个测试数据的第一行包含一个整数 n (1 &lt;&#x3D; n &lt;&#x3D; 50)，表示学生的个数，接下来的一行，包含 n 个整数，按顺序表示每个学生的能力值 ai（-50 &lt;&#x3D; ai &lt;&#x3D; 50）。接下来的一行包含两个整数，k 和 d (1 &lt;&#x3D; k &lt;&#x3D; 10, 1 &lt;&#x3D; d &lt;&#x3D; 50)。</p><p><strong>输出描述：</strong><br>输出一行表示最大的乘积。</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="type">int</span> k,d;</span><br><span class="line">    cin&gt;&gt;k&gt;&gt;d;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">result_max</span>(n,<span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(k+<span class="number">1</span>,<span class="number">-0x3f</span>));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">result_min</span>(n,<span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(k+<span class="number">1</span>,<span class="number">0x3f</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        result_max[i][<span class="number">1</span>]=arr[i];</span><br><span class="line">        result_min[i][<span class="number">1</span>]=arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=k;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">1</span>;m&lt;=d&amp;&amp;(i-m)&gt;=<span class="number">0</span>;m++)&#123;</span><br><span class="line">                result_max[i][j]=<span class="built_in">max</span>(result_max[i][j],<span class="built_in">max</span>(result_max[i-m][j<span class="number">-1</span>]*arr[i],result_min[i-m][j<span class="number">-1</span>]*arr[i]));</span><br><span class="line">                result_min[i][j]=<span class="built_in">min</span>(result_min[i][j],<span class="built_in">min</span>(result_min[i-m][j<span class="number">-1</span>]*arr[i],result_max[i-m][j<span class="number">-1</span>]*arr[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">-0x3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,result_max[i][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2全排列"><a href="#2全排列" class="headerlink" title="2全排列"></a>2<a href="https://leetcode.cn/problems/permutations/description/">全排列</a></h3><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p><p><strong>排列型回溯</strong><br>解答：选哪个数 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt; &amp;nums) &#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">path</span><span class="params">(n)</span>, <span class="title">on_path</span><span class="params">(n)</span></span>;</span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!on_path[j]) &#123;</span><br><span class="line">                    path[i] = nums[j];</span><br><span class="line">                    on_path[j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">dfs</span>(i + <span class="number">1</span>);</span><br><span class="line">                    on_path[j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>进阶版 - 包含重复元素</p><h3 id="3全排列Ⅱ"><a href="#3全排列Ⅱ" class="headerlink" title="3全排列Ⅱ"></a>3<a href="https://leetcode.cn/problems/permutations-ii/description/">全排列Ⅱ</a></h3><p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p><p>思路：先排序 使重复的元素相邻 添加判断条件</p><img src="/2024/08/17/Dynamic-programming/judge.png" class="" title="判断条件"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">path</span><span class="params">(n)</span>, <span class="title">on_path</span><span class="params">(n)</span></span>; <span class="comment">// 记录是否被选</span></span><br><span class="line"></span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (on_path[j] ||</span><br><span class="line">                    j &gt; <span class="number">0</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>] &amp;&amp; !on_path[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                path[i] = nums[j];</span><br><span class="line">                on_path[j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(i + <span class="number">1</span>);</span><br><span class="line">                on_path[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相同类型题目</p><h3 id="4字符串的排列"><a href="#4字符串的排列" class="headerlink" title="4字符串的排列"></a>4<a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=295&tqId=23291&qru=/ta/format-top101/question-ranking&sourceUrl=/exam/oj">字符串的排列</a></h3><p><strong>描述</strong><br>输入一个长度为 n 字符串，打印出该字符串中字符的所有排列，你可以以任意顺序返回这个字符串数组。</p><p>例如输入字符串ABC,则输出由字符A,B,C所能排列出来的所有字符串ABC,ACB,BAC,BCA,CBA和CAB。</p><img src="/2024/08/17/Dynamic-programming/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240818093112.png" class=""><p>数据范围： n&lt;10<br>要求：空间复杂度 O(n!)，时间复杂度 O(n!)</p><p><strong>输入描述：</strong><br>输入一个字符串,长度不超过10,字符只包括大小写字母。</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">Permutation</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="built_in">sort</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n=str.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="function">string <span class="title">path</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">on_path</span><span class="params">(n)</span></span>;<span class="comment">//记录是否被选中</span></span><br><span class="line"></span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==n)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(on_path[j]||j&gt;<span class="number">0</span>&amp;&amp;str[j<span class="number">-1</span>]==str[j]&amp;&amp;!on_path[j<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                on_path[j]=<span class="literal">true</span>;</span><br><span class="line">                path[i]=str[j];</span><br><span class="line">                <span class="built_in">dfs</span>(i+<span class="number">1</span>);</span><br><span class="line">                on_path[j]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>子集型回溯 - 考虑元素顺序</p><h3 id="5子集"><a href="#5子集" class="headerlink" title="5子集"></a>5<a href="https://leetcode.cn/problems/subsets/description/">子集</a></h3><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的<br>子集 （幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><p><strong>注意：由于[1,2] [2,1]是重复的，所以需要规定一个顺序</strong></p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> i)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;n;j++)&#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">                <span class="built_in">dfs</span>(j+<span class="number">1</span>);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>进阶版 - 包含重复元素</p><h3 id="6子集Ⅱ"><a href="#6子集Ⅱ" class="headerlink" title="6子集Ⅱ"></a>6<a href="https://leetcode.cn/problems/subsets-ii/description/">子集Ⅱ</a></h3><p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的<br>子集 （幂集）。</p><p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p><p>思路：排序 添加判断条件</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">on_path</span><span class="params">(n,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> i)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(on_path[j]||j&gt;<span class="number">0</span>&amp;&amp;nums[j<span class="number">-1</span>]==nums[j]&amp;&amp;!on_path[j<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                on_path[j]=<span class="literal">true</span>;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">                <span class="built_in">dfs</span>(j+<span class="number">1</span>);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">                on_path[j]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="7蘑菇阵"><a href="#7蘑菇阵" class="headerlink" title="7蘑菇阵"></a>7<a href="https://www.nowcoder.com/practice/ed9bc679ea1248f9a3d86d0a55c0be10?tpId=143&tags=&title=&difficulty=0&judgeStatus=0&sourceUrl=">蘑菇阵</a></h3><p><strong>描述</strong><br>现在有两个好友A和B，住在一片长有蘑菇的由n＊m个方格组成的草地，A在(1,1),B在(n,m)。现在A想要拜访B，<br>由于她只想去B的家，所以每次她只会走(i,j+1)或(i+1,j)这样的路线，<br>在草地上有k个蘑菇种在格子里(多个蘑菇可能在同一方格),问：A如果每一步随机选择的话(若她在边界上，则只有一种选择)，<br>那么她不碰到蘑菇走到B的家的概率是多少？</p><p><strong>输入描述：</strong><br>第一行N，M，K(1 ≤ N,M ≤ 20, k ≤ 100),N,M为草地大小，接下来K行，每行两个整数x，y，代表(x,y)处有一个蘑菇。</p><p><strong>输出描述：</strong><br>输出一行，代表所求概率(保留到2位小数)</p><p>思路：<br>假设P(i, j)表示从起点到(i, j)不踩到蘑菇的概率，那么该位置一定是从(i-1, j)或者(i, j-1)出走过来的。<br>而从(i-1, j)或者(i, j-1)到达(i, j)的概率是不等的，<br>比如：如果i或者j在边界，只能向一个方向移 动，此时走到(i, j)位置的概率为1，<br>当i或者j不在边界时，走到(i,j)的概率分别为0.5，<br>因此可得 出： P(i,j) &#x3D; P(i-1, j) * (i&#x3D;&#x3D;M? 1 : 0.5)+ P(i, j-1) * (j&#x3D;&#x3D;N? 1 : 0.5)<br><strong>需要注意这里的下标是从1开始的 打印要求两位小数</strong></p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, k;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m &gt;&gt; k) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">map</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="type">int</span> row, col;</span><br><span class="line">            cin &gt;&gt; row &gt;&gt; col;</span><br><span class="line">            map[row][col] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">double</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">double</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] * (j == m ? <span class="number">1</span> : <span class="number">0.5</span>) + dp[i][j - <span class="number">1</span>] *</span><br><span class="line">                                                                   (i == n ? <span class="number">1</span> : <span class="number">0.5</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (map[i][j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0.0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, dp[n][m]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8电话号码的字母组合"><a href="#8电话号码的字母组合" class="headerlink" title="8电话号码的字母组合"></a>8<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">电话号码的字母组合</a></h3><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    string MAP[10]=&#123;&quot;&quot;,&quot;&quot;,&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;&#125;;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; letterCombinations(string digits) &#123;</span><br><span class="line">        int n=digits.length();</span><br><span class="line">        if(n==0) return &#123;&#125;;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        string path(n,0);</span><br><span class="line">        function&lt;void(int)&gt; dfs=[&amp;](int i)&#123;</span><br><span class="line">            if(i==n)&#123;</span><br><span class="line">                ans.push_back(path);</span><br><span class="line">                return ;</span><br><span class="line">            &#125;</span><br><span class="line">            for(char c:MAP[digits[i]-&#x27;0&#x27;])&#123;</span><br><span class="line">                path[i]=c;</span><br><span class="line">                dfs(i+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        dfs(0);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="9组合"><a href="#9组合" class="headerlink" title="9组合"></a>9<a href="https://leetcode.cn/problems/combinations/description/">组合</a></h3><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p><p>你可以按 任何顺序 返回答案。</p><p><strong>相当于是规定长度的子集型回溯</strong><br>采取倒叙枚举 当 i&lt;d时此时枚举的长度一定不满足条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> i)&#123;</span><br><span class="line">            <span class="type">int</span> d=k-path.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">if</span>(d==<span class="number">0</span>)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;=d;j--)&#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(j);</span><br><span class="line">                <span class="built_in">dfs</span>(j<span class="number">-1</span>);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="10组合总和Ⅲ"><a href="#10组合总和Ⅲ" class="headerlink" title="10组合总和Ⅲ"></a>10<a href="https://leetcode.cn/problems/combination-sum-iii/description/">组合总和Ⅲ</a></h3><p>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：</p><ul><li>只使用数字1到9</li><li>每个数字 最多使用一次</li></ul><p>返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><p>思路：<br>和上面类似倒叙枚举<br>比如i&#x3D;5 d&#x3D;3  如果 t&gt;5+4+3-&gt; t&gt;(i+i-d+1)<em>d&#x2F;2&#x3D;(2</em>i-d+1)*d&#x2F;2<br>条件不成立</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> i,<span class="type">int</span> t)&#123;</span><br><span class="line">            <span class="type">int</span> d=k-path.<span class="built_in">size</span>();</span><br><span class="line">            <span class="comment">//剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">t</span>&lt;<span class="number">0</span>||t&gt;(<span class="number">2</span>*i-d+<span class="number">1</span>)*d/<span class="number">2</span>) <span class="keyword">return</span> ;</span><br><span class="line">            <span class="keyword">if</span>(d==<span class="number">0</span>)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;=d;j--)&#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(j);</span><br><span class="line">                <span class="built_in">dfs</span>(j<span class="number">-1</span>,t-j);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">9</span>,n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="11求和"><a href="#11求和" class="headerlink" title="11求和"></a>11<a href="https://www.nowcoder.com/practice/11cc498832db489786f8a03c3b67d02c">求和</a></h3><p><strong>描述</strong></p><p>输入两个整数 n 和 m，从数列1，2，3…….n 中随意取几个数,使其和等于 m ,要求将其中所有的可能组合列出来</p><p><strong>输入描述：</strong></p><p>每个测试输入包含2个整数,n和m</p><p><strong>输出描述：</strong></p><p>按每个组合的字典序排列输出,每行输出一种组合</p><p><strong>需要注意的是，这里要去按照字典序排列输出，与上述有所区别，从前往后遍历</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> i,<span class="type">int</span> t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t&lt;<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(j);</span><br><span class="line">            <span class="built_in">dfs</span>(j+<span class="number">1</span>,t-j);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:ans)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:v)&#123;</span><br><span class="line">            cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12马戏团"><a href="#12马戏团" class="headerlink" title="12马戏团"></a>12<a href="https://www.nowcoder.com/practice/c2afcd7353f84690bb73aa6123548770?tpId=170&&tqId=34060&qru=/ta/exam-sohu/question-ranking">马戏团</a></h3><p><strong>描述</strong></p><p>搜狐员工小王最近利用假期在外地旅游，在某个小镇碰到一个马戏团表演，精彩的表演结束后发现团长正和大伙在帐篷前激烈讨论，<br>小王打听了下了解到， 马戏团正打算出一个新节目“最高罗汉塔”，即马戏团员叠罗汉表演。考虑到安全因素，要求叠罗汉过程中，<br>站在某个人肩上的人应该既比自己矮又比自己瘦，或相等。 团长想要本次节目中的罗汉塔叠的最高，由于人数众多，正在头疼如何安排人员的问题。<br>小王觉得这个问题很简单，于是统计了参与最高罗汉塔表演的所有团员的身高体重，并且很快找到叠最高罗汉塔的人员序列。<br>现在你手上也拿到了这样一份身高体重表，请找出可以叠出的最高罗汉塔的高度，这份表中马戏团员依次编号为1到N。</p><p><strong>输入描述：</strong></p><p>首先一个正整数N，表示人员个数。 之后N行，每行三个数，分别对应马戏团员编号，体重和身高。</p><p><strong>输出描述：</strong></p><p>正整数m，表示罗汉塔的高度。</p><p>体重不等时 需要体重小的 身高低的或者相等的<br>体重相等时 身高必须相等<br>为避免体重相等时 身高更高的被选中 采取体重升序排列 体重相等时 身高降序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">int</span> id, weight, height;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (weight != p.weight) &#123;</span><br><span class="line">            <span class="keyword">return</span> weight &lt;= p.weight;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> height &gt; p.height;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">        <span class="function">vector&lt;Person&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; arr[i].id &gt;&gt; arr[i].weight &gt;&gt; arr[i].height;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j].height &lt;= arr[i].height) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13年终奖"><a href="#13年终奖" class="headerlink" title="13年终奖"></a>13<a href="https://www.nowcoder.com/practice/72a99e28381a407991f2c96d8cb238ab?tpId=49&&tqId=29305&qru=/ta/2016test/question-ranking">年终奖</a></h3><p><strong>描述</strong></p><p>小东所在公司要发年终奖，而小东恰好获得了最高福利，他要在公司年会上参与一个抽奖游戏，<br>游戏在一个6<em>6的棋盘上进行，上面放着36个价值不等的礼物，每个小的棋盘上面放置着一个礼物，<br>他需要从左上角开始游戏，每次只能向下或者向右移动一步，到达右下角停止，<br>一路上的格子里的礼物小东都能拿到，请设计一个算法使小东拿到价值最高的礼物。<br>给定一个6</em>6的矩阵board，其中每个元素为对应格子的礼物价值,左上角为[0,0],请返回能获得的最大价值，<br>保证每个礼物价值大于100小于1000。</p><p>类似不同路径问题</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bonus</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMost</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> n=board.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">-1</span>));</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> i,<span class="type">int</span> j)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span>&amp; res=memo[i][j];</span><br><span class="line">            <span class="keyword">if</span>(res!=<span class="number">-1</span>) <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">return</span> res=<span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>,j),<span class="built_in">dfs</span>(i,j<span class="number">-1</span>))+board[i][j];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(n<span class="number">-1</span>,n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="14完全平方数"><a href="#14完全平方数" class="headerlink" title="14完全平方数"></a>14<a href="https://leetcode.cn/problems/perfect-squares/description/">完全平方数</a></h3><p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。<br>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，<br>其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,n)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j*j&lt;=i;j++)&#123;</span><br><span class="line">                dp[i]=<span class="built_in">min</span>(dp[i],dp[i-j*j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="15走方格的方案数"><a href="#15走方格的方案数" class="headerlink" title="15走方格的方案数"></a>15<a href="https://www.nowcoder.com/practice/e2a22f0305eb4f2f9846e7d644dba09b?tpId=37&tqId=21314">走方格的方案数</a></h3><p><strong>描述</strong></p><p>请计算n*m的棋盘格子（n为横向的格子数，m为竖向的格子数）从棋盘左上角出发沿着边缘线从左上角走到右下角，<br>总共有多少种走法，要求不能走回头路，即：只能往右和往下走，不能往左和往上走。</p><p>注：沿棋盘格之间的边缘线行走</p><p>数据范围： 1≤n,m≤8</p><p><strong>输入描述：</strong></p><p>输入两个正整数n和m，用空格隔开。(1≤n,m≤8)</p><p><strong>输出描述：</strong></p><p>输出一行结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m+<span class="number">1</span>,<span class="number">-1</span>));</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> i,<span class="type">int</span> j)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>&amp; res=memo[i][j];</span><br><span class="line">        <span class="keyword">if</span>(res!=<span class="number">-1</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">return</span> res=<span class="built_in">dfs</span>(i<span class="number">-1</span>,j)+<span class="built_in">dfs</span>(i,j<span class="number">-1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">dfs</span>(n,m)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16跳石板"><a href="#16跳石板" class="headerlink" title="16跳石板"></a>16<a href="https://www.nowcoder.com/practice/4284c8f466814870bae7799a07d49ec8?tpId=85&&tqId=29852&qru=/ta/2017test/question-ranking">跳石板</a></h3><p><strong>描述</strong></p><p>小易来到了一条石板路前，每块石板上从1挨着编号为：1、2、3…….<br>这条石板路要根据特殊的规则才能前进：对于小易当前所在的编号为K的石板，<br>小易单次只能往前跳K的一个约数(不含1和K)步，即跳到K+X(X为K的一个非1和本身的约数)的位置。<br>小易当前处在编号为N的石板，他想跳到编号恰好为M的石板去，小易想知道最少需要跳跃几次可以到达。</p><p>例如：<br>N &#x3D; 4，M &#x3D; 24：<br>4-&gt;6-&gt;8-&gt;12-&gt;18-&gt;24<br>于是小易最少需要跳跃5次，就可以从4号石板跳到24号石板</p><p><strong>输入描述：</strong></p><p>输入为一行，有两个整数N，M，以空格隔开。 (4 ≤ N ≤ 100000) (N ≤ M ≤ 100000)<br><strong>输出描述：</strong></p><p>输出小易最少需要跳跃的步数,如果不能到达输出-1</p><h3 id="17不要二"><a href="#17不要二" class="headerlink" title="17不要二"></a>17<a href="https://www.nowcoder.com/practice/1183548cd48446b38da501e58d5944eb?tpId=85&&tqId=29840&qru=/ta/2017test/question-ranking">不要二</a></h3><p><strong>描述</strong></p><p>二货小易有一个W*H的网格盒子，网格的行编号为0<del>H-1，网格的列编号为0</del>W-1。<br>每个格子至多可以放一块蛋糕，任意两块蛋糕的欧几里得距离不能等于2。<br>对于两个格子坐标(x1,y1),(x2,y2)的欧几里得距离为:<br>( (x1-x2) * (x1-x2) + (y1-y2) * (y1-y2) ) 的算术平方根<br>小易想知道最多可以放多少块蛋糕在网格盒子里。</p><p><strong>输入描述：</strong></p><p>每组数组包含网格长宽W,H，用空格分割.(1 ≤ W、H ≤ 1000)</p><p><strong>输出描述：</strong></p><p>输出一个最多可以放的蛋糕数</p><p>思想：<br>1+3&#x3D;4<br>3+1&#x3D;4<br>2+2&#x3D;4<br>0+4&#x3D;4<br>4+0&#x3D;4</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> w,h;</span><br><span class="line">    cin&gt;&gt;w&gt;&gt;h;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(w,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(h,<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;w;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;h;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">2</span>&lt;w)&#123;</span><br><span class="line">                    dp[i+<span class="number">2</span>][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j+<span class="number">2</span>&lt;h)&#123;</span><br><span class="line">                    dp[i][j+<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18宵暗的妖怪"><a href="#18宵暗的妖怪" class="headerlink" title="18宵暗的妖怪"></a>18<a href="https://ac.nowcoder.com/acm/contest/8755/F">宵暗的妖怪</a></h3><p>题目描述<br>露米娅作为宵暗的妖怪，非常喜欢吞噬黑暗。 这天，她来到了一条路上，准备吞噬这条路上的黑暗。<br>这条道路一共被分为 n 部分，每个部分上的黑暗数量为 ai。<br>露米娅每次可以任取连续的未被吞噬过的 三部分，将其中的黑暗全部吞噬，并获得中间部分的饱食度。<br>露米娅想知道，自己能获得的饱食度最大值是多少？</p><p><strong>输入描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一行一个正整数 n ，代表道路被分的份数。</span><br><span class="line">第二行有 n 个正整数 ai</span><br><span class="line">，代表每一部分黑暗数量。</span><br><span class="line">数据范围：</span><br><span class="line">3≤n≤100000,1≤ai≤10^9</span><br></pre></td></tr></table></figure><p><strong>输出描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个正整数，代表最终饱食度的最大值。</span><br></pre></td></tr></table></figure><p>思路:<br>该元素是否被吞噬:没有被吞噬 选择前一个状态<br>被吞噬 选择上一个被吞噬的状态</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; v[i];</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">3</span>] + v[i - <span class="number">1</span>], dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19取金币"><a href="#19取金币" class="headerlink" title="19取金币"></a>19<a href="https://www.nowcoder.com/practice/cb33f5653a064b2eaf1fe30ba18f5977?tpId=295&fromPut=pc_wzcpa_labuladong_sf">取金币</a></h3><p><strong>描述</strong></p><p>给定一个长度为 n 的正整数数组 coins，每个元素表示对应位置的金币数量。<br>取位置 i 的金币时，假设左边一堆金币数量是 L，右边一堆金币数量为 R，则获得<br>L∗cost[i]∗R的积分。如果左边或右边没有金币，则金币数量视为1。<br>请你计算最多能得到多少积分。<br>数据范围：数组长度满足 1≤n≤100  ，数组中的元素满足 1≤coinsi ≤100 </p><p>解答</p><ol><li>定义状态：<br>  •设 dp[i][j] 表示从第 i 到第 j 的金币数组中，能获得的最大积分。</li><li>   状态转移方程：<br>  对于区间 [i, j]，可以选择区间内的任意一个位置 k 作为最后取的位置。其获得的积分为:L * coins[k] * R<br>  其中 L 为左边的金币数，R 为右边的金币数，L 和 R 都取决于当前的区间边界。<br>  因此状态转移方程为:dp[i][j] &#x3D; max(dp[i][j], dp[i][k-1] + dp[k+1][j] + L * coins[k] * R)</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCoins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 在数组两端加上虚拟的 1</span></span><br><span class="line">        coins.<span class="built_in">insert</span>(coins.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line">        coins.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 创建 dp 数组，初始化为 0</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 动态规划，从较小的区间长度开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; ++len) &#123;</span><br><span class="line">            <span class="comment">//枚举左边界</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - len + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                <span class="comment">//计算右边界</span></span><br><span class="line">                <span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 在 i 到 j 之间选择最后一个取的金币</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt;= j; ++k) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j],</span><br><span class="line">                                   dp[i][k - <span class="number">1</span>] + coins[i - <span class="number">1</span>] * coins[k] * coins[j + <span class="number">1</span>] + dp[k + <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回从第 1 个金币到第 n 个金币之间的最大积分</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="20N皇后"><a href="#20N皇后" class="headerlink" title="20N皇后"></a>20<a href="https://leetcode.cn/problems/n-queens/description/">N皇后</a></h3><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。<br>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<br>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。<br>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>实例</p><img src="/2024/08/17/Dynamic-programming/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240830200035.png" class="" title="实例"><p>解答<br>使用 col 数组记录该行皇后所在位置 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">col</span><span class="params">(n)</span>,<span class="title">on_path</span><span class="params">(n)</span>,<span class="title">diag1</span><span class="params">(n*<span class="number">2</span><span class="number">-1</span>)</span>,<span class="title">diag2</span><span class="params">(n*<span class="number">2</span><span class="number">-1</span>)</span></span>;</span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(r==n)&#123;</span><br><span class="line">                vector&lt;string&gt; <span class="built_in">board</span>(n);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                    board[i]=<span class="built_in">string</span>(col[i],<span class="string">&#x27;.&#x27;</span>)+<span class="string">&#x27;Q&#x27;</span>+<span class="built_in">string</span>(n<span class="number">-1</span>-col[i],<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(board);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">0</span>;c&lt;n;c++)&#123;</span><br><span class="line">                <span class="type">int</span> rc=r-c+n<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(!on_path[c]&amp;&amp;!diag1[r+c]&amp;&amp;!diag2[rc])&#123;</span><br><span class="line">                    col[r]=c;</span><br><span class="line">                    on_path[c]=diag1[r+c]=diag2[rc]=<span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">dfs</span>(r+<span class="number">1</span>);</span><br><span class="line">                    on_path[c]=diag1[r+c]=diag2[rc]=<span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="21组合总和"><a href="#21组合总和" class="headerlink" title="21组合总和"></a>21<a href="https://leetcode.cn/problems/combination-sum-ii/">组合总和</a></h3><p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用 一次 。</p><p>注意：解集不能包含重复的组合。 </p><p>先排序</p><img src="/2024/08/17/Dynamic-programming/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240904094804.png" class=""><p>图中将used的变化用橘黄色标注上，可以看出在candidates[i] &#x3D;&#x3D; candidates[i - 1]相同的情况下：</p><p>used[i - 1] &#x3D;&#x3D; true，说明同一树枝candidates[i - 1]使用过<br>used[i - 1] &#x3D;&#x3D; false，说明同一树层candidates[i - 1]使用过</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates,<span class="type">int</span> target,<span class="type">int</span> sum,<span class="type">int</span> index,vector&lt;<span class="type">bool</span>&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==sum)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;candidates.<span class="built_in">size</span>()&amp;&amp;sum+candidates[i]&lt;=target;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;candidates[i<span class="number">-1</span>]==candidates[i]&amp;&amp;!visited[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            sum+=candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            visited[i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">backtracking</span>(candidates,target,sum,i+<span class="number">1</span>,visited);</span><br><span class="line">            visited[i]=<span class="literal">false</span>;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            sum-=candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(candidates.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtracking</span>(candidates,target,<span class="number">0</span>,<span class="number">0</span>,visited);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GPT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/2024/08/17/Backpack-issues/"/>
      <url>/2024/08/17/Backpack-issues/</url>
      
        <content type="html"><![CDATA[<h3 id="1数位染色"><a href="#1数位染色" class="headerlink" title="1数位染色"></a>1<a href="https://www.nowcoder.com/practice/adf828f399de4932955734a4eac12757?tpId=230&tqId=1815295&qru=/ta/dynamic-programming/question-ranking&sourceUrl=/exam/company">数位染色</a></h3><p><strong>描述</strong><br>小红拿到了一个正整数 x 。她可以将其中一些数位染成红色。然后她想让所有染红的数位数字之和等于没染色的数位数字之和。<br>她不知道能不能达成目标。你能告诉她吗？<br><strong>输入描述：</strong><br>一个正整数 x ,1≤x≤10^18<br><strong>输出描述：</strong><br>如果小红能按要求完成染色，输出”Yes”。否则输出”No”。</p><p>0-1背包问题<br>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> x;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    string tmp=<span class="built_in">to_string</span>(x);</span><br><span class="line">    <span class="type">int</span> n=tmp.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ch:tmp)&#123;</span><br><span class="line">        sum+=(ch-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum%<span class="number">2</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(sum/<span class="number">2</span>+<span class="number">1</span>,<span class="number">-1</span>));</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> i,<span class="type">int</span> c)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> c==<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>&amp; ret=memo[i][c];</span><br><span class="line">        <span class="keyword">if</span>(ret!=<span class="number">-1</span>) <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="keyword">if</span>(c&lt;(tmp[i]-<span class="string">&#x27;0&#x27;</span>))&#123;<span class="comment">//不能选</span></span><br><span class="line">            <span class="keyword">return</span> ret=<span class="built_in">dfs</span>(i<span class="number">-1</span>,c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret=<span class="built_in">dfs</span>(i<span class="number">-1</span>,c)+<span class="built_in">dfs</span>(i<span class="number">-1</span>,c-(tmp[i]-<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dfs</span>(n<span class="number">-1</span>,sum/<span class="number">2</span>))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2目标和"><a href="#2目标和" class="headerlink" title="2目标和"></a>2<a href="https://leetcode.cn/problems/target-sum/description/">目标和</a></h3><p>给你一个非负整数数组 nums 和一个整数 target 。<br>向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：</p><ul><li>例如，nums &#x3D; [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。</li></ul><p>返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p><p>0-1背包<br>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        target+=<span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(target&lt;<span class="number">0</span>||target%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m=target/=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m+<span class="number">1</span>,<span class="number">-1</span>));</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> i,<span class="type">int</span> c)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span>) <span class="keyword">return</span> c==<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span>&amp; ret=memo[i][c];</span><br><span class="line">            <span class="keyword">if</span>(ret!=<span class="number">-1</span>) <span class="keyword">return</span> ret;</span><br><span class="line">            <span class="keyword">if</span>(c&lt;nums[i])&#123;<span class="comment">//不选</span></span><br><span class="line">                <span class="keyword">return</span> ret=<span class="built_in">dfs</span>(i<span class="number">-1</span>,c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ret=<span class="built_in">dfs</span>(i<span class="number">-1</span>,c)+<span class="built_in">dfs</span>(i<span class="number">-1</span>,c-nums[i]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(n<span class="number">-1</span>,m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3零钱兑换"><a href="#3零钱兑换" class="headerlink" title="3零钱兑换"></a>3<a href="https://www.nowcoder.com/practice/3911a20b3f8743058214ceaa099eeb45?tpId=295&tqId=988994&qru=/ta/format-top101/question-ranking&sourceUrl=/exam/oj">零钱兑换</a></h3><p><strong>描述</strong></p><p>给定数组arr，arr中所有的值都为正整数且不重复。每个值代表一种面值的货币，<br>每种面值的货币可以使用任意张， 再给定一个aim，代表要找的钱数，求组成aim的最少货币数。<br>如果无解，请返回-1.</p><p>数据范围：数组大小满足 0≤n≤10000 ， 数组中每个数字都满足 0&lt;val≤10000， 0≤aim≤5000</p><p>要求：时间复杂度 O(n×aim) ，空间复杂度 O(aim)。</p><p>完全背包问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMoney</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> aim)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> n=arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(aim+<span class="number">1</span>,<span class="number">-1</span>));</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;dfs=[&amp;](<span class="type">int</span> i,<span class="type">int</span> c)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> c==<span class="number">0</span>?<span class="number">0</span>:INT_MAX/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span>&amp;ret=memo[i][c];</span><br><span class="line">            <span class="keyword">if</span>(ret!=<span class="number">-1</span>) <span class="keyword">return</span> ret;</span><br><span class="line">            <span class="keyword">if</span>(c&lt;arr[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> ret=<span class="built_in">dfs</span>(i<span class="number">-1</span>,c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ret=<span class="built_in">min</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>,c),<span class="built_in">dfs</span>(i,c-arr[i])+<span class="number">1</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> ans=<span class="built_in">dfs</span>(n<span class="number">-1</span>,aim);</span><br><span class="line">        <span class="keyword">return</span> ans&lt;INT_MAX/<span class="number">2</span>?ans:<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> wildcard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口</title>
      <link href="/2024/08/17/Slide-the-window/"/>
      <url>/2024/08/17/Slide-the-window/</url>
      
        <content type="html"><![CDATA[<p>滑动窗口<br>代码框架（借鉴力扣大佬的<a href="https://leetcode.cn/u/labuladong/">labuladong</a>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slidingWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> valid = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="type">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">        <span class="comment">/********************/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="type">char</span> d = s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1相差不超过k的最多数"><a href="#1相差不超过k的最多数" class="headerlink" title="1相差不超过k的最多数"></a>1<a href="https://www.nowcoder.com/questionTerminal/562630ca90ac40ce89443c91060574c6">相差不超过k的最多数</a></h3><p>给定一个数组，选择一些数，要求选择的数中任意两数差的绝对值不超过,问最多能选择多少个数？<br><strong>输入描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行输入两个正整数 n和k</span><br><span class="line">第二行输入 n个正整数 ai用空格隔开，表示这个数组</span><br></pre></td></tr></table></figure><p><strong>输出描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一个正整数，代表能选的最多数量</span><br><span class="line">数据范围：</span><br><span class="line">1≤n≤2×10^5</span><br><span class="line">1≤k,ai≤10^9</span><br></pre></td></tr></table></figure><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> max_length=<span class="number">0</span>,left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> right=<span class="number">0</span>;right&lt;n;right++)&#123;</span><br><span class="line">        <span class="keyword">while</span>((arr[right]-arr[left])&gt;k)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        max_length=<span class="built_in">max</span>(max_length,right-left+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;max_length&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2长度最小的子数组"><a href="#2长度最小的子数组" class="headerlink" title="2长度最小的子数组"></a>2<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">长度最小的子数组</a></h3><p>给定一个含有 n 个正整数的数组和一个正整数 target 找出该数组中满足其总和大于等于 target 的长度最小的 子数组<br>[numsl, numsl+1, …, numsr-1, numsr] ,并返回其长度 如果不存在符合条件的子数组,返回 0 </p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>,max_length=nums.<span class="built_in">size</span>()+<span class="number">1</span>,left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right=<span class="number">0</span>;right&lt;nums.<span class="built_in">size</span>();right++)&#123;</span><br><span class="line">            sum+=nums[right];</span><br><span class="line">            <span class="keyword">while</span>(sum&gt;=target)&#123;</span><br><span class="line">                max_length=<span class="built_in">min</span>(max_length,right-left+<span class="number">1</span>);</span><br><span class="line">                sum-=nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_length&lt;=nums.<span class="built_in">size</span>()?max_length:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3无重复字符的最长子串"><a href="#3无重复字符的最长子串" class="headerlink" title="3无重复字符的最长子串"></a>3<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">无重复字符的最长子串</a></h3><p>给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">length</span>(),ans=<span class="number">0</span>,left=<span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; window;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right=<span class="number">0</span>;right&lt;n;right++)&#123;</span><br><span class="line">            <span class="type">char</span> c=s[right];</span><br><span class="line">            <span class="keyword">while</span>(window.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">                window.<span class="built_in">erase</span>(s[left++]);</span><br><span class="line">            &#125;</span><br><span class="line">            window.<span class="built_in">insert</span>(c);</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,right-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4乘积小于-K-的子数组"><a href="#4乘积小于-K-的子数组" class="headerlink" title="4乘积小于 K 的子数组"></a>4<a href="https://leetcode.cn/problems/subarray-product-less-than-k/description/">乘积小于 K 的子数组</a></h3><p>给你一个整数数组 nums 和一个整数 k ，请你返回子数组内所有元素的乘积严格小于 k 的连续子数组的数目。</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>(),ans=<span class="number">0</span>,prod=<span class="number">1</span>,left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right=<span class="number">0</span>;right&lt;n;right++)&#123;</span><br><span class="line">            prod*=nums[right];</span><br><span class="line">            <span class="keyword">while</span>(prod&gt;=k)&#123;</span><br><span class="line">                prod/=nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=right-left+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5包括不超过两种字符的最长字串"><a href="#5包括不超过两种字符的最长字串" class="headerlink" title="5包括不超过两种字符的最长字串"></a>5<a href="https://www.nowcoder.com/practice/90d6a362fa7d4c519d557da797bb02ce?tpId=196&tqId=40552">包括不超过两种字符的最长字串</a></h3><p><strong>描述</strong><br>给定一个长度为 n 的字符串，找出最多包含两种字符的最长子串 t ，返回这个最长的长度。<br>数据范围： 1≤n≤10^5 字符串种仅包含小写英文字母</p><p><strong>输入描述：</strong><br>仅一行，输入一个仅包含小写英文字母的字符串</p><p><strong>输出描述：</strong><br>输出最长子串的长度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    <span class="type">int</span> n=str.<span class="built_in">length</span>();</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> right=<span class="number">0</span>;right&lt;n;right++)&#123;</span><br><span class="line">        map[str[right]]++;</span><br><span class="line">        <span class="keyword">while</span>(map.<span class="built_in">size</span>()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            map[str[left]]--;</span><br><span class="line">            <span class="keyword">if</span>(map[str[left]]==<span class="number">0</span>)&#123;</span><br><span class="line">                map.<span class="built_in">erase</span>(str[left]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,right-left+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6DNA序列"><a href="#6DNA序列" class="headerlink" title="6DNA序列"></a>6<a href="https://www.nowcoder.com/practice/e8480ed7501640709354db1cc4ffd42a?tpId=37&tqId=21286&qru=/exam/oj/ta&sourceUrl=/exam/oj/ta?page=2&tpId=37&type=37&difficulty=undefined&judgeStatus=undefined&tags=&title=">DNA序列</a></h3><p><strong>描述</strong></p><p>一个 DNA 序列由 A&#x2F;C&#x2F;G&#x2F;T 四个字母的排列组合组成。<br>G 和 C 的比例（定义为 GC-Ratio ）是序列中 G 和 C 两个字母的总的出现次数除以总的字母数目（也就是序列长度）。<br>在基因工程中，这个比例非常重要。因为高的 GC-Ratio 可能是基因的起始点。</p><p>给定一个很长的 DNA 序列，以及限定的子串长度 N ，请帮助研究人员在给出的 DNA 序列中从左往右找出 GC-Ratio 最高且长度为 N 的第一个子串。<br>DNA序列为 ACGT 的子串有: ACG , CG , CGT 等等，但是没有 AGT ， CT 等等</p><p>数据范围：字符串长度满足 1≤n≤1000  ，输入的字符串只包含 A&#x2F;C&#x2F;G&#x2F;T 字母</p><p><strong>输入描述：</strong></p><p>输入一个string型基因序列，和int型子串的长度</p><p><strong>输出描述：</strong></p><p>找出GC比例最高的子串,如果有多个则输出第一个的子串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">string <span class="title">findHighestGCRatioSubstr</span><span class="params">(string str,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> maxGCRatio = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> currentGCRatio = <span class="number">0</span>;</span><br><span class="line">    string result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//初始化窗口</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">&#x27;G&#x27;</span>||str[i]==<span class="string">&#x27;C&#x27;</span>) currentGCRatio++;</span><br><span class="line">    &#125;</span><br><span class="line">    maxGCRatio=currentGCRatio;</span><br><span class="line">    result=str.<span class="built_in">substr</span>(<span class="number">0</span>,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> right=k;right&lt;n;right++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[right]==<span class="string">&#x27;G&#x27;</span>||str[right]==<span class="string">&#x27;C&#x27;</span>) currentGCRatio++;</span><br><span class="line">        <span class="keyword">if</span>(str[right-k]==<span class="string">&#x27;G&#x27;</span>||str[right-k]==<span class="string">&#x27;C&#x27;</span>) currentGCRatio--;</span><br><span class="line">        <span class="keyword">if</span>(currentGCRatio&gt;maxGCRatio)&#123;</span><br><span class="line">            maxGCRatio=currentGCRatio;</span><br><span class="line">            result=str.<span class="built_in">substr</span>(right-k+<span class="number">1</span>,k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    cin&gt;&gt;str&gt;&gt;k;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">findHighestGCRatioSubstr</span>(str, k)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7连续最大和"><a href="#7连续最大和" class="headerlink" title="7连续最大和"></a>7<a href="https://www.nowcoder.com/practice/5a304c109a544aef9b583dce23f5f5db?tpId=85&&tqId=29858&qru=/ta/2017test/question-ranking">连续最大和</a></h3><p><strong>描述</strong></p><p>一个数组有 N 个元素，求连续子数组的最大和。 例如：[-1,2,1]，和最大的连续子数组为[2,1]，其和为 3</p><p><strong>输入描述：</strong></p><p>输入为两行。 第一行一个整数n(1 &lt;&#x3D; n &lt;&#x3D; 100000)，表示一共有n个元素 第二行为n个数，即每个元素,每个整数都在32位int范围内。以空格分隔。</p><p><strong>输出描述：</strong></p><p>所有连续子数组中和最大的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum=arr[<span class="number">0</span>],ans=arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> right=<span class="number">1</span>;right&lt;n;right++)&#123;</span><br><span class="line">        sum=<span class="built_in">max</span>(arr[right],sum+arr[right]);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> wildcard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JetBrain IDEA全家桶破解激活利器</title>
      <link href="/2024/08/14/how-to-hack-JetBrain/"/>
      <url>/2024/08/14/how-to-hack-JetBrain/</url>
      
        <content type="html"><![CDATA[<h3 id="1-首先安装好你的JetBrain全家桶任意软件，打开JETBRA-IN-CHECKER官方网站，找一个有颜色的链接点进去"><a href="#1-首先安装好你的JetBrain全家桶任意软件，打开JETBRA-IN-CHECKER官方网站，找一个有颜色的链接点进去" class="headerlink" title="1.首先安装好你的JetBrain全家桶任意软件，打开JETBRA.IN CHECKER官方网站，找一个有颜色的链接点进去"></a>1.首先安装好你的JetBrain全家桶任意软件，打开<a href="https://3.jetbra.in/">JETBRA.IN CHECKER</a>官方网站，找一个有颜色的链接点进去</h3><img src="/2024/08/14/how-to-hack-JetBrain/checker.png" class=""><h3 id="2-进去后，点击上面置顶的jetbra-zip，下载该文件到本地，并且解压出来，解压出来的文件放在不易删除的地方，记住不能删除解压后的文件"><a href="#2-进去后，点击上面置顶的jetbra-zip，下载该文件到本地，并且解压出来，解压出来的文件放在不易删除的地方，记住不能删除解压后的文件" class="headerlink" title="2.进去后，点击上面置顶的jetbra.zip，下载该文件到本地，并且解压出来，解压出来的文件放在不易删除的地方，记住不能删除解压后的文件"></a>2.进去后，点击上面置顶的jetbra.zip，下载该文件到本地，并且解压出来，解压出来的文件放在不易删除的地方，记住不能删除解压后的文件</h3><img src="/2024/08/14/how-to-hack-JetBrain/jetbrain.png" class=""><h3 id="3-进去解压后的文件，进入scripts文件夹，如果你是-Linux-MacOS，运行-install-sh，如果你是-Windows，运行-install-all-users-vbs-或者-install-current-user-vbs（此操作作用是配置-IDE-的-JVM-参数，并添加至环境变量），顾名思义，第一个是为所有用户安装，第二个是为当前用户安装。当然如果你动手能力强，你可以自行配置，参考readme-txt文件即可"><a href="#3-进去解压后的文件，进入scripts文件夹，如果你是-Linux-MacOS，运行-install-sh，如果你是-Windows，运行-install-all-users-vbs-或者-install-current-user-vbs（此操作作用是配置-IDE-的-JVM-参数，并添加至环境变量），顾名思义，第一个是为所有用户安装，第二个是为当前用户安装。当然如果你动手能力强，你可以自行配置，参考readme-txt文件即可" class="headerlink" title="3.进去解压后的文件，进入scripts文件夹，如果你是 Linux&#x2F;MacOS，运行 install.sh，如果你是 Windows，运行 install-all-users.vbs 或者 install-current-user.vbs（此操作作用是配置 IDE 的 JVM 参数，并添加至环境变量），顾名思义，第一个是为所有用户安装，第二个是为当前用户安装。当然如果你动手能力强，你可以自行配置，参考readme.txt文件即可"></a>3.进去解压后的文件，进入scripts文件夹，如果你是 Linux&#x2F;MacOS，运行 install.sh，如果你是 Windows，运行 install-all-users.vbs 或者 install-current-user.vbs（此操作作用是配置 IDE 的 JVM 参数，并添加至环境变量），顾名思义，第一个是为所有用户安装，第二个是为当前用户安装。当然如果你动手能力强，你可以自行配置，参考readme.txt文件即可</h3><img src="/2024/08/14/how-to-hack-JetBrain/scripts.png" class=""><h3 id="4-打开你安装好的JetBrain某款软件，找到激活的界面，选择Activation-code-方式激活"><a href="#4-打开你安装好的JetBrain某款软件，找到激活的界面，选择Activation-code-方式激活" class="headerlink" title="4.打开你安装好的JetBrain某款软件，找到激活的界面，选择Activation code 方式激活"></a>4.打开你安装好的JetBrain某款软件，找到激活的界面，选择Activation code 方式激活</h3><img src="/2024/08/14/how-to-hack-JetBrain/code.png" class=""><h3 id="5-然后回到刚刚的进去的下载jetbra-zip文件的网站，找到你需要的激活的软件，点击星星的位置，复制激活码"><a href="#5-然后回到刚刚的进去的下载jetbra-zip文件的网站，找到你需要的激活的软件，点击星星的位置，复制激活码" class="headerlink" title="5.然后回到刚刚的进去的下载jetbra.zip文件的网站，找到你需要的激活的软件，点击星星的位置，复制激活码"></a>5.然后回到刚刚的进去的下载jetbra.zip文件的网站，找到你需要的激活的软件，点击星星的位置，复制激活码</h3><img src="/2024/08/14/how-to-hack-JetBrain/jetbrain2.png" class=""><h3 id="6-把激活码粘贴到Activation-code的位置，点击activate即可"><a href="#6-把激活码粘贴到Activation-code的位置，点击activate即可" class="headerlink" title="6.把激活码粘贴到Activation code的位置，点击activate即可"></a>6.把激活码粘贴到Activation code的位置，点击activate即可</h3><img src="/2024/08/14/how-to-hack-JetBrain/code2.png" class=""><h3 id="7-然后。你就可以看到熟悉的绿色了，到此使用jetbrains激活码破解激活完成"><a href="#7-然后。你就可以看到熟悉的绿色了，到此使用jetbrains激活码破解激活完成" class="headerlink" title="7.然后。你就可以看到熟悉的绿色了，到此使用jetbrains激活码破解激活完成"></a>7.然后。你就可以看到熟悉的绿色了，到此使用jetbrains激活码破解激活完成</h3>]]></content>
      
      
      <categories>
          
          <category> GPT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何注册chatgpt账号?</title>
      <link href="/2024/03/06/how-to-create-a-account/"/>
      <url>/2024/03/06/how-to-create-a-account/</url>
      
        <content type="html"><![CDATA[<h1 id="1、注册-outlook-邮箱"><a href="#1、注册-outlook-邮箱" class="headerlink" title="1、注册 outlook 邮箱"></a>1、注册 outlook 邮箱</h1><h2 id="1-1-访问-outlook"><a href="#1-1-访问-outlook" class="headerlink" title="1.1 访问 outlook"></a>1.1 访问 outlook</h2><p><a href="https://outlook.com/">https://outlook.com</a></p><p>选择右上角的 登录</p><img src="/2024/03/06/how-to-create-a-account/46.png" class="" title="登录"><h2 id="1-2-立即创建"><a href="#1-2-立即创建" class="headerlink" title="1.2 立即创建"></a>1.2 立即创建</h2><img src="/2024/03/06/how-to-create-a-account/47.png" class="" title="立即创建"><h2 id="1-3-设置邮箱账号"><a href="#1-3-设置邮箱账号" class="headerlink" title="1.3 设置邮箱账号"></a>1.3 设置邮箱账号</h2><img src="/2024/03/06/how-to-create-a-account/48.png" class="" title="设置邮箱账号"><h2 id="1-4-设置个人信息-姓名"><a href="#1-4-设置个人信息-姓名" class="headerlink" title="1.4 设置个人信息-姓名"></a>1.4 设置个人信息-姓名</h2><img src="/2024/03/06/how-to-create-a-account/49.png" class="" title="设置个人信息"><h2 id="1-5-设置个人信息-出生日期，地址"><a href="#1-5-设置个人信息-出生日期，地址" class="headerlink" title="1.5 设置个人信息-出生日期，地址"></a>1.5 设置个人信息-出生日期，地址</h2><p>建议将地址设置为US</p><img src="/2024/03/06/how-to-create-a-account/50.png" class="" title="设置个人信息"><h2 id="1-6-通过真人检验"><a href="#1-6-通过真人检验" class="headerlink" title="1.6 通过真人检验"></a>1.6 通过真人检验</h2><img src="/2024/03/06/how-to-create-a-account/51.png" class="" title="真人验证"><h1 id="2、注册-OpenAI-账号"><a href="#2、注册-OpenAI-账号" class="headerlink" title="2、注册 OpenAI 账号"></a>2、注册 OpenAI 账号</h1><h2 id="2-1-申请-openai"><a href="#2-1-申请-openai" class="headerlink" title="2.1 申请 openai"></a>2.1 申请 openai</h2><p>首先打开 OpenAI 的账户注册页面，输入邮箱:<br><a href="https://chat.openai.com/">https://chat.openai.com/</a></p><img src="/2024/03/06/how-to-create-a-account/52.png" class="" title="选择注册sign up"><h2 id="2-2-输入邮箱"><a href="#2-2-输入邮箱" class="headerlink" title="2.2 输入邮箱"></a>2.2 输入邮箱</h2><p>将刚刚注册的邮箱输入即可</p><img src="/2024/03/06/how-to-create-a-account/53.png" class="" title="输入邮箱"><h2 id="2-3-创建账号"><a href="#2-3-创建账号" class="headerlink" title="2.3 创建账号"></a>2.3 创建账号</h2><p>输入密码</p><img src="/2024/03/06/how-to-create-a-account/54.png" class="" title="输入密码"><h2 id="2-4-等待验证"><a href="#2-4-等待验证" class="headerlink" title="2.4 等待验证"></a>2.4 等待验证</h2><img src="/2024/03/06/how-to-create-a-account/55.png" class="" title="等待验证"><h2 id="2-4-验证邮箱"><a href="#2-4-验证邮箱" class="headerlink" title="2.4 验证邮箱"></a>2.4 验证邮箱</h2><p>验证通过之后，openai会向你的邮箱发送验证邮件</p><img src="/2024/03/06/how-to-create-a-account/56.png" class="" title="邮箱验证"><p>回到刚刚创建的邮箱中检测收件箱</p><img src="/2024/03/06/how-to-create-a-account/57.png" class="" title="收件箱"><p>点击验证即可</p><img src="/2024/03/06/how-to-create-a-account/58.png" class="" title="邮件验证"><h2 id="2-5-输入个人信息"><a href="#2-5-输入个人信息" class="headerlink" title="2.5 输入个人信息"></a>2.5 输入个人信息</h2><p>邮件验证通过之后，需要输入个人信息</p><img src="/2024/03/06/how-to-create-a-account/59.png" class="" title="输入个人信息"><h2 id="2-6-拼图验证"><a href="#2-6-拼图验证" class="headerlink" title="2.6 拼图验证"></a>2.6 拼图验证</h2><p>拼图验证是否是真人</p><img src="/2024/03/06/how-to-create-a-account/60.png" class="" title="拼图验证"><h2 id="2-7-开始聊天"><a href="#2-7-开始聊天" class="headerlink" title="2.7 开始聊天"></a>2.7 开始聊天</h2><p>拼图验证通过，开始使用chatgpt账号</p><img src="/2024/03/06/how-to-create-a-account/61.png" class="" title="开始聊天"><p>ChatGPT 用户获取 GPT-4 的使用权限，是通过购买 GPT Plus 会员，会员的收费标准是 20 美元&#x2F;每月。<br><a href="https://jackma-yj.github.io/2024/02/24/how-to-upgrade-chatgpt4.0/">GPT4-0 充值流程</a><br>购买 GPT Plus 会员后，可以在 Chat 界面选择 GPT4 进行聊天。</p>]]></content>
      
      
      <categories>
          
          <category> GPT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ChatGPT Plus 代充、代升级以及成品号购买</title>
      <link href="/2024/03/04/proxy-charging,%20proxy-upgrading-and-purchase-of-product-numbers/"/>
      <url>/2024/03/04/proxy-charging,%20proxy-upgrading-and-purchase-of-product-numbers/</url>
      
        <content type="html"><![CDATA[<h1 id="ChatGPT-Plus-升级服务介绍"><a href="#ChatGPT-Plus-升级服务介绍" class="headerlink" title="ChatGPT Plus 升级服务介绍"></a>ChatGPT Plus 升级服务介绍</h1><p>商品介绍<br>ChatGPT Plus 产品介绍及权益，ChatGPT Plus 是官方的付费会员服务，升级后可以享受强大的 GPT-4。官方订阅费用为每月 20 美元，订阅者将享有一系列的权益：</p><ul><li>GPT-4 模型：质量比3.5高出数倍！并自带联网，自动切换适合你提示语提问的内容。</li><li>AI 绘画（Dall-E3 模型）：直接向 GPT 提问画画。</li><li>GPT-4V，即上传图片给 GPT 分析解读，结合绘画出图能力，提示生产力。</li><li>语音对话：Voice 聊天功能，需要官方版 ChatGPT APP。</li></ul><h2 id="ChatGPT-Plus成品号与代升级"><a href="#ChatGPT-Plus成品号与代升级" class="headerlink" title="ChatGPT Plus成品号与代升级"></a>ChatGPT Plus成品号与代升级</h2><p>ChatGPT 升级的困难是什么？国人没有海外信用卡，OpenAI 对于信用卡的风控非常严格，对于支付环境都有很高的要求。当你在支付的时候，往往是没法支付成功的。于是本站迎合市场需求，推出了两种服务：<br>1）ChatGPT Plus 成品号出售   2）代充代升级。</p><h3 id="ChatGPT-Plus购买流程"><a href="#ChatGPT-Plus购买流程" class="headerlink" title="ChatGPT Plus购买流程"></a>ChatGPT Plus购买流程</h3><p>ChatGPT Plus成品号购买<br>ChatGPT Plus 成品号 – 无需你注册，拿来登录就用，高效快捷<br>这个商品适合不需要你自己有账号，你想买来就能用的 ChatGPT Plus 账号。 本商品，手工注册，安全有保障。你下单后，我将为你手动注册并充值 – 包售后<br>费用是 199 元，点击查看与购买&gt;，包下号，为你全程交付。后续续费时只需 185 元&#x2F;月，随用随续，按月订阅的。</p><h3 id="ChatGPT-Plus-代充升级"><a href="#ChatGPT-Plus-代充升级" class="headerlink" title="ChatGPT Plus 代充升级"></a>ChatGPT Plus 代充升级</h3><p>ChatGPT Plus 会员的代充、代付、代升级流程如下：<br>1）不需要账号密码，点击左下角的升级，在弹窗里点击升级</p><img src="/2024/03/04/proxy-charging,%20proxy-upgrading-and-purchase-of-product-numbers/2.png" class="" title="复制支付链接"><p>2）如果你能到付款页面，则发送支付页面的网址给我，即可替你完成充值&amp;升级<br>费用是 185 元，点击查看与购买&gt;，包下号，为你全程交付。后续续费时只需 180 元&#x2F;月，随用随续，按月订阅的。</p>]]></content>
      
      
      <categories>
          
          <category> GPT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Onlyfans如何搜索博主?</title>
      <link href="/2024/03/01/how-to-search-for-bloggers-on-onlyfans/"/>
      <url>/2024/03/01/how-to-search-for-bloggers-on-onlyfans/</url>
      
        <content type="html"><![CDATA[<h1 id="1-OnlyFans搜索功能概览"><a href="#1-OnlyFans搜索功能概览" class="headerlink" title="1.OnlyFans搜索功能概览"></a>1.OnlyFans搜索功能概览</h1><p>在OnlyFans上搜索特定博主不像在其他社交媒体平台上那样直观，主要是因为OnlyFans的搜索功能相对有限，并且平台在设计上更注重隐私和独家内容。<br>比如，我们现在想在onlyfans上面看hongkongdoll的视频，如果直接在搜索栏进行搜索，结果如下：</p><img src="/2024/03/01/how-to-search-for-bloggers-on-onlyfans/38.png" class="" title="搜索结果"><p>发现什么内容都没有，是关键词的问题吗？换成hongkong试试呢</p><img src="/2024/03/01/how-to-search-for-bloggers-on-onlyfans/39.png" class="" title="搜索结果"><p>依然还是找不到任何内容,这到底是为什么呢?其实，并不是我们的关键词错了，而是onlyfans为了所谓的用户隐私才故意设置了搜素限制。</p><h1 id="2-如何在Onlyfans上面搜索"><a href="#2-如何在Onlyfans上面搜索" class="headerlink" title="2.如何在Onlyfans上面搜索"></a>2.如何在Onlyfans上面搜索</h1><p>这里主要介绍三种在Onlyfans上面搜索博主的方式，分别是官方服务、社媒跳转和第三方搜索引擎。</p><h2 id="2-1使用Onlyfans官方搜索服务"><a href="#2-1使用Onlyfans官方搜索服务" class="headerlink" title="2.1使用Onlyfans官方搜索服务"></a>2.1使用Onlyfans官方搜索服务</h2><p>我在官网上面找到了如下公告:</p><img src="/2024/03/01/how-to-search-for-bloggers-on-onlyfans/40.png" class="" title="官网公告"><p>根据官网公告，如果你已经关注了某个博主，那么你可以直接用搜索栏搜素到该博主的信息。<br>但是如果你没有关注，那么你只能搜索到博主的帖子内容，而不能搜素到博主的主页。</p><h2 id="2-2通过社交媒体跳转的方式"><a href="#2-2通过社交媒体跳转的方式" class="headerlink" title="2.2通过社交媒体跳转的方式"></a>2.2通过社交媒体跳转的方式</h2><p>如果你在其他平台上面关注了某个博主，例如X，那么这个博主可能会把ta的onlyfans链接放在某个帖子里面，你可以到相应平台去看一看。<br>此外，如果你已经知道某个博主的用户名，那么也可以通过拼接域名的方式来访问，即: onlyfans.com&#x2F;&lt;用户名&gt;，比如hongkongdoll的主页就是onlyfans.com&#x2F;hongkongdoll</p><h2 id="2-3使用第三方搜索工具"><a href="#2-3使用第三方搜索工具" class="headerlink" title="2.3使用第三方搜索工具"></a>2.3使用第三方搜索工具</h2><p>那如果你既没有关注某个博主，也不知道博主的其他社交媒体，该怎么办呢？<br>这里就要向大家介绍今天的重头戏，就是第三方onlyfans搜索引擎。<br><a href="https://onlysearch.co/">https://onlysearch.co</a></p><p>onlysearch就是这么一个平台，它爬取了onlyfans上面所有的用户信息，存放在数据库中。然后你就可以用onlysearch提供的搜索服务，来搜索某个博主并跳转到ta的首页啦~<br>还是拿hongkongdoll举例，我们先进入onlysearch首页，</p><img src="/2024/03/01/how-to-search-for-bloggers-on-onlyfans/41.png" class="" title="搜索框"><p>输入hongkongdoll，然后点击search</p><img src="/2024/03/01/how-to-search-for-bloggers-on-onlyfans/42.png" class="" title="搜索结果"><p>然后就可以搜索到了，点击左下方的open onlyfans，就能跳转到hongkongdoll的onlyfans首页，接下来就能开始愉快的订阅啦~<br><a href="https://jackma-yj.github.io/2024/02/24/how-to-subscribe-to-onlyfans/">国内如何订阅 onlyfans?</a></p>]]></content>
      
      
      <categories>
          
          <category> onlyfans </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何购买midjourney</title>
      <link href="/2024/02/24/how-to-purchase-midjourney/"/>
      <url>/2024/02/24/how-to-purchase-midjourney/</url>
      
        <content type="html"><![CDATA[<ol><li>Midjourney介绍<br>Midjourney 是一款备受欢迎的人工智能生成图像工具，它可以通过输入文字描述，自动生成精美的图像。与许多其他图像生成工具不同，Midjourney 不需要安装任何软件，也不受个人电脑性能的限制，因为它运行在云端服务器上。要使用 Midjourney，只需拥有一个 Discord 帐号并加入相应的 Discord 频道即可。</li><li>midjourney多少钱一个月<br>下面是我为大家总结的midjourney的不同订阅计划的费用和区别<img src="/2024/02/24/how-to-purchase-midjourney/18.png" class="" title="图片引用方法一"></li></ol><p>对于一般用户而言，选择基础计划或者标准计划就可以满足日常使用需求。</p><p>对于商业用途而言，建议选择专业计划或者大型计划。</p><p>3.1 如何使用虚拟卡来订阅midjourney</p><ol><li>首先，去<a href="https://bewildcard.com/i/CHATGPTYJM">wildcard</a>上面购买一张虚拟信用卡，可以得到一张虚拟信用卡和卡片信息。这一步需要9.99美元的开卡费，开完卡之后这就是你的信用卡了，你可以用支付宝向里面充值金额来支付midjourney的订阅。</li><li>登录你的<a href="https://www.midjourney.com/explore">Midjourney账户</a>，进入订阅中心（如果是在Discord频道里，则是在频道输入框输入&#x2F;subscribe，然后点击一下，再回车）</li><li>选择您需要订阅的会员计划，选择月支付&#x2F;年支付</li><li>进入支付页面，选择银行卡支付</li><li>把你在第一步购买到的虚拟信用卡卡号、有效期、CVV码等信息填写到对应的地方<img src="/2024/02/24/how-to-purchase-midjourney/19.png" class="" title="图片引用方法一"></li><li>填写完信息之后，点击确认订阅就可以啦</li></ol>]]></content>
      
      
      <categories>
          
          <category> midjourney </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国内如何订阅onlyfans?</title>
      <link href="/2024/02/24/how-to-subscribe-to-onlyfans/"/>
      <url>/2024/02/24/how-to-subscribe-to-onlyfans/</url>
      
        <content type="html"><![CDATA[<p>什么是onlyfans?<br>OnlyFans是一种内容订阅服务，成立于2016年，允许内容创作者从用户那里获得资金，用户需要支付订阅费用才能查看他们的内容。它在多个领域受到欢迎，包括音乐、健身、摄影，以及成人内容创作。</p><p>注册OnlyFans账户<br>访问OnlyFans官网。<br>创建账户，填写必要的个人信息。<br>邮箱验证及账户激活。</p><p>订阅onlyfans<br>在onlyfans中搜索你想要喜欢并想要订阅的内容，for example Hong Kong doll</p><p>选择订阅时间</p><img src="/2024/02/24/how-to-subscribe-to-onlyfans/5.png" class="" title="图片引用方法一"><p>开通虚拟卡<br>什么是虚拟信用卡<br>简单的说来，就是如果你需要订阅国外的服务（如chatgpt或者onlyfans）的话，就必须要有国外的信用卡。但是国内不是没有办法开通国外信用卡吗，所以就需要使用虚拟信用卡，然后用这张虚拟卡去订阅服务。</p><p>这里我比较推荐虚拟卡平台<a href="https://bewildcard.com/i/CHATGPTYJM">wildcard</a></p><p>如何开通虚拟卡<br>开通步骤如下：</p><p>首先点击链接进入WildCard 一分钟开卡，轻松订阅海外软件服务</p><p>进入网站首页，填写相关信息开卡，中途需要用到支付宝认证，但是只需要扫码即可，不需要上传身份证或者人脸识别。</p><p>支付宝认证完之后，选择卡片开通的时长（根据个人需要选择，个人推荐两年的，比较划算，每天不到两毛钱）。</p><img src="/2024/02/24/how-to-subscribe-to-onlyfans/6.png" class="" title="图片引用方法一"><p>支付之后需要几分钟的时间等待开通成功。开通成功之后就可以拿到一张虚拟卡。</p><p>然后在订阅的链接里面，把下面卡片的信息复制粘贴进去就行了。</p><img src="/2024/02/24/how-to-subscribe-to-onlyfans/7.png" class="" title="图片引用方法一"><p>使用虚拟卡订阅<br>接下来详细看如何用购买的虚拟卡订阅onlyfans。</p><p>回到onlyfans，在点击订阅时长之后，提示添加信用卡</p><img src="/2024/02/24/how-to-subscribe-to-onlyfans/8.png" class="" title="图片引用方法一"><p>然后点击添加信用卡</p><img src="/2024/02/24/how-to-subscribe-to-onlyfans/9.png" class="" title="图片引用方法一"><p>上面需要的每一项信息，都可以直接在虚拟卡网页上看到，直接像下面这样复制过去即可：</p><img src="/2024/02/24/how-to-subscribe-to-onlyfans/10.png" class="" title="图片引用方法一"><p>支付成功之后，便可以放心去体验！</p>]]></content>
      
      
      <categories>
          
          <category> onlyfans </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wildcard使用教程</title>
      <link href="/2024/02/24/wildcard-tutorial/"/>
      <url>/2024/02/24/wildcard-tutorial/</url>
      
        <content type="html"><![CDATA[<ol><li>什么是虚拟信用卡<br>WildCard 虚拟信用卡提供快速、安全的在线支付解决方案，支持通过云闪付充值，不收取消费和提现手续费，特设美国网络环境和英国手机号服务，以及直接客服支持，适合全球业务需求。</li></ol><p>简单的说来，就是如果你订阅国外的服务（如chatgpt或者onlyfans）的话，需要用到国外的信用卡。而wildcard就可以给你提供一个国外的虚拟信用卡，让你可以去订阅相关服务。</p><ol start="2"><li>如何开通虚拟卡<br>开通步骤如下：</li></ol><p>首先点击链接进入 WildCard<a href="https://bewildcard.com/i/CHATGPTYJM">wildcard</a> 一分钟开卡，轻松订阅海外软件服务</p><p>进入网站首页之后，点击立即体验</p><img src="/2024/02/24/wildcard-tutorial/11.png" class="" title="官网"><p>然后点击“立即开卡”</p><img src="/2024/02/24/wildcard-tutorial/12.png" class="" title="立即开卡"><p>然后输入你的手机号码接收验证码（使用邀请码CHATYJM可以在开卡时优惠2美元）</p><img src="/2024/02/24/wildcard-tutorial/13.png" class="" title="图片引用方法一"><p>然后填写你的个人信息</p><img src="/2024/02/24/wildcard-tutorial/14.png" class="" title="图片引用方法一"><p>点击下一步，进行支付宝扫码认证（不需要人脸或身份证）</p><img src="/2024/02/24/wildcard-tutorial/15.png" class="" title="图片引用方法一"><p>支付宝认证完之后，选择卡片开通的时长（根据个人需要选择，个人推荐两年的，比较划算）。此外，如果你是从上面的链接进入，可以得到2美金优惠</p><img src="/2024/02/24/wildcard-tutorial/16.png" class="" title="图片引用方法一"><p>支付之后需要几分钟的时间等待开通成功。</p><p>开通成功之后就可以使用虚拟信用卡来订阅服务啦，直接在订阅的地方，把下面卡片的信息复制粘贴进去就行了。</p><img src="/2024/02/24/wildcard-tutorial/17.png" class="" title="图片引用方法一"><p>总结<br>开卡网站：WildCard 一分钟开卡，轻松订阅海外软件服务</p>]]></content>
      
      
      <categories>
          
          <category> wildcard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPT4-0充值流程</title>
      <link href="/2024/02/24/how-to-upgrade-chatgpt4.0/"/>
      <url>/2024/02/24/how-to-upgrade-chatgpt4.0/</url>
      
        <content type="html"><![CDATA[<p>如果你有 ChatGPT 账号，需要升级4.0，那么这篇文章适合你继续阅读！现在要有效开通的方式有两种：<br>1，网页版通过信用卡订阅<br>2，ChatGPT App礼品卡订阅<br>以下是两种开通方法的喂饭级教程：<br>【网页版充值】<br>充值前请先确认以下三点：<br>1，ChatGPT账户正常登陆。<br>2，充值过程中始终保持美区环境，且开启全局模式。<br>3，使用Chrome浏览器无痕浏览打开openAI。<br>进入Openai官网网址：<a href="https://chat.openai.com/">https://chat.openai.com</a><br>第一步：点击左下角Upgrade to Plus</p><img src="/2024/02/24/how-to-upgrade-chatgpt4.0/1.png" class="" title="图片引用方法一"><p>第二步，复制支付页面的URL</p><img src="/2024/02/24/how-to-upgrade-chatgpt4.0/2.png" class="" title="图片引用方法一"><p><a href="https://bewildcard.com/i/CHATGPTYJM">WildCard | 一分钟开卡，轻松订阅海外软件服务</a></p><p>这家国内的公司应该是专门解决这个问题的，会使用支付宝进行实名认证，大家不用担心，这个是因为走银联通道购汇需要，不用担心安全问题（开户需要填写个人真实信息）</p><p>第二步：获取信用卡<br>（这一步最重要） 因为目前Open AI不支持国内卡，目前比较流行且有效的获取支持订阅的卡的方式–国外信用卡<br>开的卡是有效期2年的虚拟信用卡，开卡费包含两年年费，算下来100元RMB，一天2 毛钱不到，其它费用无，后续自己订阅产品，用多少充多少。<br>开卡之后进入主页面，点击一键升级chatgpt</p><img src="/2024/02/24/how-to-upgrade-chatgpt4.0/3.png" class="" title="图片引用方法一"><p>点击我的邮箱账号符合要求</p><img src="/2024/02/24/how-to-upgrade-chatgpt4.0/36.png" class="" title="图片引用方法一"><p>根据自己的需求选择个人或者团队，点击下一步</p><img src="/2024/02/24/how-to-upgrade-chatgpt4.0/37.png" class="" title="图片引用方法一"><p>将页面向下划，把刚才复制的URL粘贴到对应的框框中，点击确定支付并升级级</p><img src="/2024/02/24/how-to-upgrade-chatgpt4.0/4.png" class="" title="图片引用方法一"><p>恭喜成功升级chatgpt plus!</p>]]></content>
      
      
      <categories>
          
          <category> GPT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
