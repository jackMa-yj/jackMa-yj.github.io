<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>常规题</title>
      <link href="/2024/08/17/Regular-questions/"/>
      <url>/2024/08/17/Regular-questions/</url>
      
        <content type="html"><![CDATA[<h3 id="1素数回文"><a href="#1素数回文" class="headerlink" title="1素数回文"></a>1<a href="https://www.nowcoder.com/practice/d638855898fb4d22bc0ae9314fed956f?tpId=290&tqId=140152&qru=/ta/beginner-programmers/question-ranking&sourceUrl=/exam/oj?page=1&tab=%25E8%25AF%25AD%25E6%25B3%2595%25E7%25AF%2587&topicId=290">素数回文</a></h3><p><strong>描述</strong><br>现在给出一个素数，这个素数满足两点：</p><ol><li>只由1-9组成，并且每个数只出现一次，如13,23,1289。</li><li>位数从高到低为递减或递增，如2459，87631。</li></ol><p>请你判断一下，这个素数的回文数是否为素数（13的回文数是131,127的回文数是12721）。</p><p><strong>输入描述：</strong><br>输入只有1行。<br>第1行输入一个整数t，保证t为素数。<br>数据保证：9&lt;t&lt;109</p><p><strong>输出描述：</strong><br>输出一行字符串，如果t的回文数仍是素数，则输出“prime”，否则输出”noprime”。</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">long</span> <span class="type">long</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">2</span>;i*i&lt;=num;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    string tmp=t;</span><br><span class="line">    <span class="built_in">reverse</span>(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>());</span><br><span class="line">    tmp.<span class="built_in">erase</span>(tmp.<span class="built_in">begin</span>());</span><br><span class="line">    t+=tmp;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ret=<span class="built_in">atol</span>(t.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isPrime</span>(ret)) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;prime&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;noprime&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2活动安排"><a href="#2活动安排" class="headerlink" title="2活动安排"></a>2<a href="https://www.nowcoder.com/practice/16d971e9e42e4f3b9b1e2b8794796a43?tpId=308&tqId=2373697&qru=/ta/algorithm-start/question-ranking&sourceUrl=/exam/oj?page=1&tab=%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587&topicId=308">活动安排</a></h3><p><strong>描述</strong><br>给定 n 个活动，每个活动安排的时间为[ai,bi)<br>求最多可以选择多少个活动，满足选择的活动时间两两之间没有重合。</p><p><strong>输入描述：</strong><br>第一行输入一个整数<br>n (1 ≤ n ≤ 2*10^5)，表示可选活动个数。<br>接下来的 n 行，每行输入两个整数 ai , bi(0 ≤ ai &lt;bi ≤ 10^ 9 )，表示第 i 个活动的时间。</p><p><strong>输出描述：</strong><br>输出一行一个整数，表示最多可选择的活动数。</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Activity</span>&#123;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(Activity a,Activity b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.end&lt;b.end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="function">vector&lt;Activity&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;arr[i].start&gt;&gt;arr[i].end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>(),compare);</span><br><span class="line">    <span class="type">int</span> count=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> prevEnd=arr[<span class="number">0</span>].end;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i].start&gt;=prevEnd)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            prevEnd=arr[i].end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3手套"><a href="#3手套" class="headerlink" title="3手套"></a>3<a href="https://www.nowcoder.com/practice/365d5722fff640a0b6684391153e58d8?tpId=49&&tqId=29337&qru=/ta/2016test/question-ranking">手套</a></h3><p><strong>描述</strong></p><p>在地下室里放着n种颜色的手套，手套分左右手，但是每种颜色的左右手手套个数不一定相同。A先生现在要出门，<br>所以他要去地下室选手套。但是昏暗的灯光让他无法分辨手套的颜色，只能分辨出左右手。所以他会多拿一些手套，<br>然后选出一双颜色相同的左右手手套。现在的问题是，他至少要拿多少只手套(左手加右手)，才能保证一定能选出一双颜色相同的手套。<br>给定颜色种数n(1≤n≤13),同时给定两个长度为n的数组left,right,分别代表每种颜色左右手手套的数量。数据保证左右的手套总数均不超过26，且一定存在至少一种合法方案。</p><p><strong>测试样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4,[0,7,1,6],[1,5,0,6]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回：10(解释：可以左手手套取2只，右手手套取8只)</span><br></pre></td></tr></table></figure><p>思路：</p><p>如果某个颜色没有手套，就必须得把该颜色对应的另一边手套累加起来。<br>先计算出左手和右手手套的总数，然后减去各自的最少的数再加一<br>这样就可以保证取出的手套至少每种都有一只<br>计算总数的时候，要找出手套数量最少的那个颜色<br>比较两者较小的那个数，决定先取左手还是先取右手<br>最后再加上另一种手套的一只就行<br>当左右手中存在手套为零时，可以进行“忽略”</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Gloves</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinimum</span><span class="params">(<span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt; left, vector&lt;<span class="type">int</span>&gt; right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> leftsum = <span class="number">0</span>, leftmin = INT_MAX, rightsum = <span class="number">0</span>, rightmin = INT_MAX;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left[i] == <span class="number">0</span> || right[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                ans += left[i] + right[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                leftsum += left[i];</span><br><span class="line">                leftmin = <span class="built_in">min</span>(leftmin, left[i]);</span><br><span class="line">                rightsum += right[i];</span><br><span class="line">                rightmin = <span class="built_in">min</span>(rightmin, right[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += <span class="built_in">min</span>(leftsum - leftmin + <span class="number">1</span>, rightsum - rightmin + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4有假币"><a href="#4有假币" class="headerlink" title="4有假币"></a>4<a href="https://www.nowcoder.com/questionTerminal/1d18c0841e64454cbc3afaea05e2f63c">有假币</a></h3><p>居然有假币！ 现在猪肉涨了，但是农民的工资却不见涨啊，没钱怎么买猪肉啊。nowcoder这就去买猪肉，<br>结果找来的零钱中有假币！！！可惜nowcoder 一不小心把它混进了一堆真币里面去了。<br>只知道假币的重量比真币的质量要轻，给你一个天平（天平两端能容纳无限个硬币），<br>请用最快的时间把那个可恶的假币找出来。</p><p><strong>输入描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1≤n≤2^30,输入0结束程序。</span><br></pre></td></tr></table></figure><p><strong>输出描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最多要称几次一定能把那个假币找出来？</span><br></pre></td></tr></table></figure><p>思路：<br>平均分三份是最快的方法，两份进行称重（对比出三个的重量 ），后对最重的那份再次进行称重，<br>直到称重的个数不足2个时则结束，获得假币 如果无法平均分3分则余数要么是1要么是2，<br>因为是要最多称几次，n&#x3D;n&#x2F;3+1 满足每次取最大 分称3份，取两份一样多的过秤，<br>然后把三份中最多的那份继续分，直到硬币剩余0或1时截至</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">3</span>)&#123;</span><br><span class="line">                n=n/<span class="number">3</span>+<span class="number">1</span>;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                n/=<span class="number">3</span>;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5五子棋"><a href="#5五子棋" class="headerlink" title="5五子棋"></a>5<a href="https://www.nowcoder.com/practice/a811535fed784ea492b63622c28c75c5?tpId=3&tags=&title=&difficulty=0&judgeStatus=0&sourceUrl=">五子棋</a></h3><p><strong>描述</strong></p><p>NowCoder最近爱上了五子棋，现在给你一个棋局，请你帮忙判断其中有没有五子连珠（超过五颗也算）。</p><p><strong>输入描述：</strong><br>输入有多组数据，每组数据为一张20x20的棋盘。<br>其中黑子用“*”表示，白子用“+”表示，空白位置用“.”表示。</p><p><strong>输出描述：</strong><br>如果棋盘上存在五子连珠（无论哪种颜色的棋子），输入“Yes”，否则输出“No”。</p><p>思路：<br>判断一个点位上的四个方向是否有一个存在五子连珠(0,1) (1,0) (1,1) (1,-1)</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkDirection</span><span class="params">(vector&lt;string&gt;&amp; board, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> dx, <span class="type">int</span> dy)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> player = board[x][y];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> newX = x + i * dx;</span><br><span class="line">        <span class="type">int</span> newY = y + i * dy;</span><br><span class="line">        <span class="keyword">if</span> (newX &lt; <span class="number">0</span> || newX &gt;= <span class="number">20</span> || newY &lt; <span class="number">0</span> || newY &gt;= <span class="number">20</span> ||</span><br><span class="line">                board[newX][newY] != player) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasFiveInARow</span><span class="params">(vector&lt;string&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">checkDirection</span>(board, i, j, <span class="number">1</span>, <span class="number">-1</span>) ||</span><br><span class="line">                        <span class="built_in">checkDirection</span>(board, i, j, <span class="number">0</span>, <span class="number">1</span>) || <span class="built_in">checkDirection</span>(board, i, j, <span class="number">1</span>, <span class="number">1</span>) ||</span><br><span class="line">                        <span class="built_in">checkDirection</span>(board, i, j, <span class="number">1</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">board</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; board[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            cin &gt;&gt; board[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">hasFiveInARow</span>(board)) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6逆波兰表达式求值"><a href="#6逆波兰表达式求值" class="headerlink" title="6逆波兰表达式求值"></a>6<a href="https://leetcode.cn/problems/8Zf90G/description/">逆波兰表达式求值</a></h3><p>根据 逆波兰表示法，求该后缀表达式的计算结果。</p><p>有效的算符包括 +、-、*、&#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p>说明：</p><ul><li>整数除法只保留整数部分。</li><li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li></ul><p>经典后序遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNumber</span><span class="params">(string ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(ch==<span class="string">&quot;+&quot;</span>||ch==<span class="string">&quot;-&quot;</span>||ch==<span class="string">&quot;*&quot;</span>||ch==<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> n=tokens.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            string tmp=tokens[i];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isNumber</span>(tmp))&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">atoi</span>(tmp.<span class="built_in">c_str</span>()));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> num2=st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> num1=st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">switch</span>(tmp[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                        st.<span class="built_in">push</span>(num1+num2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                        st.<span class="built_in">push</span>(num1-num2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                        st.<span class="built_in">push</span>(num1*num2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                        st.<span class="built_in">push</span>(num1/num2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="9kotori和迷宫"><a href="#9kotori和迷宫" class="headerlink" title="9kotori和迷宫"></a>9<a href="https://ac.nowcoder.com/acm/problem/50041">kotori和迷宫</a></h3><p><strong>题目描述</strong><br>kotori在一个n*m迷宫里，迷宫的最外层被岩浆淹没，无法涉足，迷宫内有k个出口。kotori只能上下左右四个方向移动。她想知道有多少出口是她能到达的，最近的出口离她有多远？</p><p><strong>输入描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行为两个整数n和m，代表迷宫的行和列数 (1≤n,m≤30)</span><br><span class="line">后面紧跟着n行长度为m的字符串来描述迷宫。&#x27;k&#x27;代表kotori开始的位置，</span><br><span class="line">&#x27;.&#x27;代表道路，&#x27;*&#x27;代表墙壁，&#x27;e&#x27;代表出口。保证输入合法。</span><br></pre></td></tr></table></figure><p><strong>输出描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">若有出口可以抵达，则输出2个整数，第一个代表kotori可选择的出口的数量，</span><br><span class="line">第二个代表kotori到最近的出口的步数。（注意，kotori到达出口一定会离开迷宫）</span><br><span class="line">若没有出口可以抵达，则输出-1。</span><br></pre></td></tr></table></figure><p>思路：<br>出口不止一个，需要比较进行比较 选择最优<br>BFS可以用来寻找最优方案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 定义方向数组，表示上下左右四个方向的移动</span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Position</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">maze</span><span class="params">(n)</span></span>;</span><br><span class="line">    queue&lt;Position&gt; q;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取迷宫并找到kotori的起始位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; maze[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maze[i][j] == <span class="string">&#x27;k&#x27;</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;i, j, <span class="number">0</span>&#125;);</span><br><span class="line">                visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> exit_count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> min_distance = <span class="number">0x3f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BFS搜索</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Position cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否到达出口</span></span><br><span class="line">        <span class="keyword">if</span> (maze[cur.x][cur.y] == <span class="string">&#x27;e&#x27;</span>) &#123;</span><br><span class="line">            exit_count++;</span><br><span class="line">            min_distance = <span class="built_in">min</span>(min_distance, cur.step);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扩展到四个方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> nx = cur.x + dx[i];</span><br><span class="line">            <span class="type">int</span> ny = cur.y + dy[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断新位置是否在迷宫内，并且可以走</span></span><br><span class="line">            <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; m &amp;&amp; !visited[nx][ny] &amp;&amp; maze[nx][ny] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                visited[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;nx, ny, cur.step + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">if</span> (exit_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; exit_count &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; min_distance &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8走迷宫"><a href="#8走迷宫" class="headerlink" title="8走迷宫"></a>8<a href="https://www.nowcoder.com/practice/6276dbbda7094978b0e9ebb183ba37b9">走迷宫</a></h3><p><strong>描述</strong><br>NowCoder最喜欢游乐场的迷宫游戏，他和小伙伴们比赛谁先走出迷宫。<br>现在把迷宫的地图给你，你能帮他算出最快走出迷宫需要多少步吗？</p><p><strong>输入描述：</strong><br>输入包含多组数据。<br>每组数据包含一个10*10，由“#”和“.”组成的迷宫。其中“#”代表墙；“.”代表通路。<br>入口在第一行第二列；出口在最后一行第九列。<br>从任意一个“.”点都能一步走到上下左右四个方向的“.”点。</p><p><strong>输出描述：</strong><br>对应每组数据，输出从入口到出口最短需要几步。</p><p>和上面的题目一样的思路BFS</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Position</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(vector&lt;string&gt;&amp; maze)</span></span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(<span class="number">10</span>,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(<span class="number">10</span>,<span class="literal">false</span>));</span><br><span class="line">    queue&lt;Position&gt; q;</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    visited[<span class="number">0</span>][<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        Position cur=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cur.x==<span class="number">9</span>&amp;&amp;cur.y==<span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> cur.step;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">            <span class="type">int</span> newX=cur.x+dx[k];</span><br><span class="line">            <span class="type">int</span> newY=cur.y+dy[k];</span><br><span class="line">            <span class="keyword">if</span>(newX&gt;=<span class="number">0</span>&amp;&amp;newX&lt;<span class="number">10</span>&amp;&amp;newY&gt;=<span class="number">0</span>&amp;&amp;newY&lt;<span class="number">10</span>&amp;&amp;!visited[newX][newY]&amp;&amp;maze[newX][newY]!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;newX,newY,cur.step+<span class="number">1</span>&#125;);</span><br><span class="line">                visited[newX][newY]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">maze</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;maze[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            cin&gt;&gt;maze[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;<span class="built_in">bfs</span>(maze)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9电话号码"><a href="#9电话号码" class="headerlink" title="9电话号码"></a>9<a href="https://www.nowcoder.com/practice/ceb89f19187b4de3997d9cdef2d551e8?tpId=3&tqId=10926&qru=/ta/hackathon/question-ranking">电话号码</a></h3><p><strong>描述</strong></p><img src="/2024/08/17/Regular-questions/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240818181439.png" class=""><p>上图是一个电话的九宫格，如你所见一个数字对应一些字母，因此在国外企业喜欢把电话号码设计成与自己公司名字相对应。<br>例如公司的Help Desk号码是4357，因为4对应H、3对应E、5对应L、7对应P，因此4357就是HELP。<br>同理，TUT-GLOP就代表888-4567、310-GINO代表310-4466。<br>NowCoder刚进入外企，并不习惯这样的命名方式，现在给你一串电话号码列表，请你帮他转换成数字形式的号码，并去除重复的部分。</p><p><strong>输入描述：</strong><br>输入包含多组数据。<br>每组数据第一行包含一个正整数n（1≤n≤1024）。<br>紧接着n行，每行包含一个电话号码，电话号码仅由连字符“-”、数字和大写字母组成。<br>没有连续出现的连字符，并且排除连字符后长度始终为7（美国电话号码只有7位）。</p><p><strong>输出描述：</strong><br>对应每一组输入，按照字典顺序输出不重复的标准数字形式电话号码，即“xxx-xxxx”形式。<br>每个电话号码占一行，每组数据之后输出一个空行作为间隔符。</p>]]></content>
      
      
      <categories>
          
          <category> wildcard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2024/08/17/Dynamic-programming/"/>
      <url>/2024/08/17/Dynamic-programming/</url>
      
        <content type="html"><![CDATA[<h3 id="1合唱团"><a href="#1合唱团" class="headerlink" title="1合唱团"></a>1<a href="https://www.nowcoder.com/practice/661c49118ca241909add3a11c96408c8">合唱团</a></h3><p><strong>描述</strong><br>有 n 个学生站成一排，每个学生有一个能力值，牛牛想从这 n 个学生中按照顺序选取 k 名学生，要求相邻两个学生的位置编号的差不超过 d，使得这 k 个学生的能力值的乘积最大，你能返回最大的乘积吗？</p><p><strong>输入描述：</strong><br>每个输入包含 1 个测试用例。每个测试数据的第一行包含一个整数 n (1 &lt;&#x3D; n &lt;&#x3D; 50)，表示学生的个数，接下来的一行，包含 n 个整数，按顺序表示每个学生的能力值 ai（-50 &lt;&#x3D; ai &lt;&#x3D; 50）。接下来的一行包含两个整数，k 和 d (1 &lt;&#x3D; k &lt;&#x3D; 10, 1 &lt;&#x3D; d &lt;&#x3D; 50)。</p><p><strong>输出描述：</strong><br>输出一行表示最大的乘积。</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="type">int</span> k,d;</span><br><span class="line">    cin&gt;&gt;k&gt;&gt;d;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">result_max</span>(n,<span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(k+<span class="number">1</span>,<span class="number">-0x3f</span>));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">result_min</span>(n,<span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(k+<span class="number">1</span>,<span class="number">0x3f</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        result_max[i][<span class="number">1</span>]=arr[i];</span><br><span class="line">        result_min[i][<span class="number">1</span>]=arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=k;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">1</span>;m&lt;=d&amp;&amp;(i-m)&gt;=<span class="number">0</span>;m++)&#123;</span><br><span class="line">                result_max[i][j]=<span class="built_in">max</span>(result_max[i][j],<span class="built_in">max</span>(result_max[i-m][j<span class="number">-1</span>]*arr[i],result_min[i-m][j<span class="number">-1</span>]*arr[i]));</span><br><span class="line">                result_min[i][j]=<span class="built_in">min</span>(result_min[i][j],<span class="built_in">min</span>(result_min[i-m][j<span class="number">-1</span>]*arr[i],result_max[i-m][j<span class="number">-1</span>]*arr[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">-0x3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,result_max[i][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2全排列"><a href="#2全排列" class="headerlink" title="2全排列"></a>2<a href="https://leetcode.cn/problems/permutations/description/">全排列</a></h3><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p><p><strong>排列型回溯</strong><br>解答：选哪个数 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt; &amp;nums) &#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">path</span><span class="params">(n)</span>, <span class="title">on_path</span><span class="params">(n)</span></span>;</span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!on_path[j]) &#123;</span><br><span class="line">                    path[i] = nums[j];</span><br><span class="line">                    on_path[j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">dfs</span>(i + <span class="number">1</span>);</span><br><span class="line">                    on_path[j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>进阶版 - 包含重复元素</p><h3 id="3全排列Ⅱ"><a href="#3全排列Ⅱ" class="headerlink" title="3全排列Ⅱ"></a>3<a href="https://leetcode.cn/problems/permutations-ii/description/">全排列Ⅱ</a></h3><p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p><p>思路：先排序 使重复的元素相邻 添加判断条件</p><img src="/2024/08/17/Dynamic-programming/judge.png" class="" title="判断条件"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">path</span><span class="params">(n)</span>, <span class="title">on_path</span><span class="params">(n)</span></span>; <span class="comment">// 记录是否被选</span></span><br><span class="line"></span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (on_path[j] ||</span><br><span class="line">                    j &gt; <span class="number">0</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>] &amp;&amp; !on_path[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                path[i] = nums[j];</span><br><span class="line">                on_path[j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(i + <span class="number">1</span>);</span><br><span class="line">                on_path[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相同类型题目</p><h3 id="4字符串的排列"><a href="#4字符串的排列" class="headerlink" title="4字符串的排列"></a>4<a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=295&tqId=23291&qru=/ta/format-top101/question-ranking&sourceUrl=/exam/oj">字符串的排列</a></h3><p><strong>描述</strong><br>输入一个长度为 n 字符串，打印出该字符串中字符的所有排列，你可以以任意顺序返回这个字符串数组。</p><p>例如输入字符串ABC,则输出由字符A,B,C所能排列出来的所有字符串ABC,ACB,BAC,BCA,CBA和CAB。</p><img src="/2024/08/17/Dynamic-programming/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240818093112.png" class=""><p>数据范围： n&lt;10<br>要求：空间复杂度 O(n!)，时间复杂度 O(n!)</p><p><strong>输入描述：</strong><br>输入一个字符串,长度不超过10,字符只包括大小写字母。</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">Permutation</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="built_in">sort</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n=str.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="function">string <span class="title">path</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">on_path</span><span class="params">(n)</span></span>;<span class="comment">//记录是否被选中</span></span><br><span class="line"></span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==n)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(on_path[j]||j&gt;<span class="number">0</span>&amp;&amp;str[j<span class="number">-1</span>]==str[j]&amp;&amp;!on_path[j<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                on_path[j]=<span class="literal">true</span>;</span><br><span class="line">                path[i]=str[j];</span><br><span class="line">                <span class="built_in">dfs</span>(i+<span class="number">1</span>);</span><br><span class="line">                on_path[j]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>子集型回溯 - 考虑元素顺序</p><h3 id="5子集"><a href="#5子集" class="headerlink" title="5子集"></a>5<a href="https://leetcode.cn/problems/subsets/description/">子集</a></h3><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的<br>子集 （幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> i)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;n;j++)&#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">                <span class="built_in">dfs</span>(j+<span class="number">1</span>);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>进阶版 - 包含重复元素</p><h3 id="6子集Ⅱ"><a href="#6子集Ⅱ" class="headerlink" title="6子集Ⅱ"></a>6<a href="https://leetcode.cn/problems/subsets-ii/description/">子集Ⅱ</a></h3><p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的<br>子集 （幂集）。</p><p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p><p>思路：排序 添加判断条件</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">on_path</span><span class="params">(n,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> i)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(on_path[j]||j&gt;<span class="number">0</span>&amp;&amp;nums[j<span class="number">-1</span>]==nums[j]&amp;&amp;!on_path[j<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                on_path[j]=<span class="literal">true</span>;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">                <span class="built_in">dfs</span>(j+<span class="number">1</span>);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">                on_path[j]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="7幸运的袋子"><a href="#7幸运的袋子" class="headerlink" title="7幸运的袋子"></a>7<a href="https://www.nowcoder.com/practice/a5190a7c3ec045ce9273beebdfe029ee?tpId=85&&tqId=29839&qru=/ta/2017test/question-ranking">幸运的袋子</a></h3><p><strong>描述</strong><br>一个袋子里面有n个球，每个球上面都有一个号码(拥有相同号码的球是无区别的)。如果一个袋子是幸运的当且仅当所有球的号码的和大于所有球的号码的积。<br>例如：如果袋子里面的球的号码是{1, 1, 2, 3}，这个袋子就是幸运的，因为1 + 1 + 2 + 3 &gt; 1 * 1 * 2 * 3<br>你可以适当从袋子里移除一些球(可以移除0个,但是别移除完)，要使移除后的袋子是幸运的。现在让你编程计算一下你可以获得的多少种不同的幸运的袋子。</p><p><strong>输入描述：</strong><br>第一行输入一个正整数n(n ≤ 1000) 第二行为n个数正整数xi(xi ≤ 1000)</p><p><strong>输出描述：</strong><br>输出可以产生的幸运的袋子数</p><p>思路：先排序 </p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> pos,<span class="type">int</span> sum,<span class="type">int</span> multi)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=pos;i&lt;arr.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        sum+=arr[i];</span><br><span class="line">        multi*=arr[i];</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;multi)&#123;</span><br><span class="line">            count+=<span class="number">1</span>+<span class="built_in">dfs</span>(arr,i+<span class="number">1</span>,sum,multi);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[i]==<span class="number">1</span>)&#123;</span><br><span class="line">            count+=<span class="built_in">dfs</span>(arr,i+<span class="number">1</span>,sum,multi);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        sum-=arr[i];</span><br><span class="line">        multi/=arr[i];</span><br><span class="line">        <span class="comment">//去重</span></span><br><span class="line">        <span class="keyword">while</span>((i+<span class="number">1</span>&lt;arr.<span class="built_in">size</span>())&amp;&amp;arr[i]==arr[i+<span class="number">1</span>]) i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());</span><br><span class="line">    cout&lt;&lt;<span class="built_in">dfs</span>(arr,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8蘑菇阵"><a href="#8蘑菇阵" class="headerlink" title="8蘑菇阵"></a>8<a href="https://www.nowcoder.com/practice/ed9bc679ea1248f9a3d86d0a55c0be10?tpId=143&tags=&title=&difficulty=0&judgeStatus=0&sourceUrl=">蘑菇阵</a></h3><p><strong>描述</strong><br>现在有两个好友A和B，住在一片长有蘑菇的由n＊m个方格组成的草地，A在(1,1),B在(n,m)。现在A想要拜访B，<br>由于她只想去B的家，所以每次她只会走(i,j+1)或(i+1,j)这样的路线，<br>在草地上有k个蘑菇种在格子里(多个蘑菇可能在同一方格),问：A如果每一步随机选择的话(若她在边界上，则只有一种选择)，<br>那么她不碰到蘑菇走到B的家的概率是多少？</p><p><strong>输入描述：</strong><br>第一行N，M，K(1 ≤ N,M ≤ 20, k ≤ 100),N,M为草地大小，接下来K行，每行两个整数x，y，代表(x,y)处有一个蘑菇。</p><p><strong>输出描述：</strong><br>输出一行，代表所求概率(保留到2位小数)</p><p>思路：<br>假设P(i, j)表示从起点到(i, j)不踩到蘑菇的概率，那么该位置一定是从(i-1, j)或者(i, j-1)出走过来的。<br>而从(i-1, j)或者(i, j-1)到达(i, j)的概率是不等的，<br>比如：如果i或者j在边界，只能向一个方向移 动，此时走到(i, j)位置的概率为1，<br>当i或者j不在边界时，走到(i,j)的概率分别为0.5，<br>因此可得 出： P(i,j) &#x3D; P(i-1, j) * (i&#x3D;&#x3D;M? 1 : 0.5)+ P(i, j-1) * (j&#x3D;&#x3D;N? 1 : 0.5)<br><strong>需要注意这里的下标是从1开始的 打印要求两位小数</strong></p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, k;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m &gt;&gt; k) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">map</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="type">int</span> row, col;</span><br><span class="line">            cin &gt;&gt; row &gt;&gt; col;</span><br><span class="line">            map[row][col] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">double</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">double</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] * (j == m ? <span class="number">1</span> : <span class="number">0.5</span>) + dp[i][j - <span class="number">1</span>] *</span><br><span class="line">                                                                   (i == n ? <span class="number">1</span> : <span class="number">0.5</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (map[i][j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0.0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, dp[n][m]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GPT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/2024/08/17/Backpack-issues/"/>
      <url>/2024/08/17/Backpack-issues/</url>
      
        <content type="html"><![CDATA[<h3 id="1数位染色"><a href="#1数位染色" class="headerlink" title="1数位染色"></a>1<a href="https://www.nowcoder.com/practice/adf828f399de4932955734a4eac12757?tpId=230&tqId=1815295&qru=/ta/dynamic-programming/question-ranking&sourceUrl=/exam/company">数位染色</a></h3><p><strong>描述</strong><br>小红拿到了一个正整数 x 。她可以将其中一些数位染成红色。然后她想让所有染红的数位数字之和等于没染色的数位数字之和。<br>她不知道能不能达成目标。你能告诉她吗？<br><strong>输入描述：</strong><br>一个正整数 x ,1≤x≤10^18<br><strong>输出描述：</strong><br>如果小红能按要求完成染色，输出”Yes”。否则输出”No”。</p><p>0-1背包问题<br>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> x;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    string tmp=<span class="built_in">to_string</span>(x);</span><br><span class="line">    <span class="type">int</span> n=tmp.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ch:tmp)&#123;</span><br><span class="line">        sum+=(ch-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum%<span class="number">2</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(sum/<span class="number">2</span>+<span class="number">1</span>,<span class="number">-1</span>));</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> i,<span class="type">int</span> c)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> c==<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>&amp; ret=memo[i][c];</span><br><span class="line">        <span class="keyword">if</span>(ret!=<span class="number">-1</span>) <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="keyword">if</span>(c&lt;(tmp[i]-<span class="string">&#x27;0&#x27;</span>))&#123;<span class="comment">//不能选</span></span><br><span class="line">            <span class="keyword">return</span> ret=<span class="built_in">dfs</span>(i<span class="number">-1</span>,c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret=<span class="built_in">dfs</span>(i<span class="number">-1</span>,c)+<span class="built_in">dfs</span>(i<span class="number">-1</span>,c-(tmp[i]-<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dfs</span>(n<span class="number">-1</span>,sum/<span class="number">2</span>))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2目标和"><a href="#2目标和" class="headerlink" title="2目标和"></a>2<a href="https://leetcode.cn/problems/target-sum/description/">目标和</a></h3><p>给你一个非负整数数组 nums 和一个整数 target 。<br>向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：</p><ul><li>例如，nums &#x3D; [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。</li></ul><p>返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p><p>0-1背包<br>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        target+=<span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(target&lt;<span class="number">0</span>||target%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m=target/=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m+<span class="number">1</span>,<span class="number">-1</span>));</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> i,<span class="type">int</span> c)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span>) <span class="keyword">return</span> c==<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span>&amp; ret=memo[i][c];</span><br><span class="line">            <span class="keyword">if</span>(ret!=<span class="number">-1</span>) <span class="keyword">return</span> ret;</span><br><span class="line">            <span class="keyword">if</span>(c&lt;nums[i])&#123;<span class="comment">//不选</span></span><br><span class="line">                <span class="keyword">return</span> ret=<span class="built_in">dfs</span>(i<span class="number">-1</span>,c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ret=<span class="built_in">dfs</span>(i<span class="number">-1</span>,c)+<span class="built_in">dfs</span>(i<span class="number">-1</span>,c-nums[i]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(n<span class="number">-1</span>,m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3<a href=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> wildcard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口</title>
      <link href="/2024/08/17/Slide-the-window/"/>
      <url>/2024/08/17/Slide-the-window/</url>
      
        <content type="html"><![CDATA[<h3 id="1相差不超过k的最多数"><a href="#1相差不超过k的最多数" class="headerlink" title="1相差不超过k的最多数"></a>1<a href="https://www.nowcoder.com/questionTerminal/562630ca90ac40ce89443c91060574c6">相差不超过k的最多数</a></h3><p>给定一个数组，选择一些数，要求选择的数中任意两数差的绝对值不超过,问最多能选择多少个数？<br><strong>输入描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行输入两个正整数 n和k</span><br><span class="line">第二行输入 n个正整数 ai用空格隔开，表示这个数组</span><br></pre></td></tr></table></figure><p><strong>输出描述:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一个正整数，代表能选的最多数量</span><br><span class="line">数据范围：</span><br><span class="line">1≤n≤2×10^5</span><br><span class="line">1≤k,ai≤10^9</span><br></pre></td></tr></table></figure><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> max_length=<span class="number">0</span>,left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> right=<span class="number">0</span>;right&lt;n;right++)&#123;</span><br><span class="line">        <span class="keyword">while</span>((arr[right]-arr[left])&gt;k)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        max_length=<span class="built_in">max</span>(max_length,right-left+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;max_length&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2长度最小的子数组"><a href="#2长度最小的子数组" class="headerlink" title="2长度最小的子数组"></a>2<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">长度最小的子数组</a></h3><p>给定一个含有 n 个正整数的数组和一个正整数 target 找出该数组中满足其总和大于等于 target 的长度最小的 子数组<br>[numsl, numsl+1, …, numsr-1, numsr] ,并返回其长度 如果不存在符合条件的子数组,返回 0 </p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>,max_length=nums.<span class="built_in">size</span>()+<span class="number">1</span>,left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right=<span class="number">0</span>;right&lt;nums.<span class="built_in">size</span>();right++)&#123;</span><br><span class="line">            sum+=nums[right];</span><br><span class="line">            <span class="keyword">while</span>(sum&gt;=target)&#123;</span><br><span class="line">                max_length=<span class="built_in">min</span>(max_length,right-left+<span class="number">1</span>);</span><br><span class="line">                sum-=nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_length&lt;=nums.<span class="built_in">size</span>()?max_length:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3无重复字符的最长子串"><a href="#3无重复字符的最长子串" class="headerlink" title="3无重复字符的最长子串"></a>3<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">无重复字符的最长子串</a></h3><p>给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">length</span>(),ans=<span class="number">0</span>,left=<span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; window;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right=<span class="number">0</span>;right&lt;n;right++)&#123;</span><br><span class="line">            <span class="type">char</span> c=s[right];</span><br><span class="line">            <span class="keyword">while</span>(window.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">                window.<span class="built_in">erase</span>(s[left++]);</span><br><span class="line">            &#125;</span><br><span class="line">            window.<span class="built_in">insert</span>(c);</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,right-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4乘积小于-K-的子数组"><a href="#4乘积小于-K-的子数组" class="headerlink" title="4乘积小于 K 的子数组"></a>4<a href="https://leetcode.cn/problems/subarray-product-less-than-k/description/">乘积小于 K 的子数组</a></h3><p>给你一个整数数组 nums 和一个整数 k ，请你返回子数组内所有元素的乘积严格小于 k 的连续子数组的数目。</p><p>解答</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>(),ans=<span class="number">0</span>,prod=<span class="number">1</span>,left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right=<span class="number">0</span>;right&lt;n;right++)&#123;</span><br><span class="line">            prod*=nums[right];</span><br><span class="line">            <span class="keyword">while</span>(prod&gt;=k)&#123;</span><br><span class="line">                prod/=nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=right-left+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5包括不超过两种字符的最长字串"><a href="#5包括不超过两种字符的最长字串" class="headerlink" title="5包括不超过两种字符的最长字串"></a>5<a href="https://www.nowcoder.com/practice/90d6a362fa7d4c519d557da797bb02ce?tpId=196&tqId=40552">包括不超过两种字符的最长字串</a></h3><p><strong>描述</strong><br>给定一个长度为 n 的字符串，找出最多包含两种字符的最长子串 t ，返回这个最长的长度。<br>数据范围： 1≤n≤10^5 字符串种仅包含小写英文字母</p><p><strong>输入描述：</strong><br>仅一行，输入一个仅包含小写英文字母的字符串</p><p><strong>输出描述：</strong><br>输出最长子串的长度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    <span class="type">int</span> n=str.<span class="built_in">length</span>();</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> right=<span class="number">0</span>;right&lt;n;right++)&#123;</span><br><span class="line">        map[str[right]]++;</span><br><span class="line">        <span class="keyword">while</span>(map.<span class="built_in">size</span>()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            map[str[left]]--;</span><br><span class="line">            <span class="keyword">if</span>(map[str[left]]==<span class="number">0</span>)&#123;</span><br><span class="line">                map.<span class="built_in">erase</span>(str[left]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,right-left+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> wildcard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JetBrain IDEA全家桶破解激活利器</title>
      <link href="/2024/08/14/how-to-hack-JetBrain/"/>
      <url>/2024/08/14/how-to-hack-JetBrain/</url>
      
        <content type="html"><![CDATA[<h3 id="1-首先安装好你的JetBrain全家桶任意软件，打开JETBRA-IN-CHECKER官方网站，找一个有颜色的链接点进去"><a href="#1-首先安装好你的JetBrain全家桶任意软件，打开JETBRA-IN-CHECKER官方网站，找一个有颜色的链接点进去" class="headerlink" title="1.首先安装好你的JetBrain全家桶任意软件，打开JETBRA.IN CHECKER官方网站，找一个有颜色的链接点进去"></a>1.首先安装好你的JetBrain全家桶任意软件，打开<a href="https://3.jetbra.in/">JETBRA.IN CHECKER</a>官方网站，找一个有颜色的链接点进去</h3><img src="/2024/08/14/how-to-hack-JetBrain/checker.png" class=""><h3 id="2-进去后，点击上面置顶的jetbra-zip，下载该文件到本地，并且解压出来，解压出来的文件放在不易删除的地方，记住不能删除解压后的文件"><a href="#2-进去后，点击上面置顶的jetbra-zip，下载该文件到本地，并且解压出来，解压出来的文件放在不易删除的地方，记住不能删除解压后的文件" class="headerlink" title="2.进去后，点击上面置顶的jetbra.zip，下载该文件到本地，并且解压出来，解压出来的文件放在不易删除的地方，记住不能删除解压后的文件"></a>2.进去后，点击上面置顶的jetbra.zip，下载该文件到本地，并且解压出来，解压出来的文件放在不易删除的地方，记住不能删除解压后的文件</h3><img src="/2024/08/14/how-to-hack-JetBrain/jetbrain.png" class=""><h3 id="3-进去解压后的文件，进入scripts文件夹，如果你是-Linux-MacOS，运行-install-sh，如果你是-Windows，运行-install-all-users-vbs-或者-install-current-user-vbs（此操作作用是配置-IDE-的-JVM-参数，并添加至环境变量），顾名思义，第一个是为所有用户安装，第二个是为当前用户安装。当然如果你动手能力强，你可以自行配置，参考readme-txt文件即可"><a href="#3-进去解压后的文件，进入scripts文件夹，如果你是-Linux-MacOS，运行-install-sh，如果你是-Windows，运行-install-all-users-vbs-或者-install-current-user-vbs（此操作作用是配置-IDE-的-JVM-参数，并添加至环境变量），顾名思义，第一个是为所有用户安装，第二个是为当前用户安装。当然如果你动手能力强，你可以自行配置，参考readme-txt文件即可" class="headerlink" title="3.进去解压后的文件，进入scripts文件夹，如果你是 Linux&#x2F;MacOS，运行 install.sh，如果你是 Windows，运行 install-all-users.vbs 或者 install-current-user.vbs（此操作作用是配置 IDE 的 JVM 参数，并添加至环境变量），顾名思义，第一个是为所有用户安装，第二个是为当前用户安装。当然如果你动手能力强，你可以自行配置，参考readme.txt文件即可"></a>3.进去解压后的文件，进入scripts文件夹，如果你是 Linux&#x2F;MacOS，运行 install.sh，如果你是 Windows，运行 install-all-users.vbs 或者 install-current-user.vbs（此操作作用是配置 IDE 的 JVM 参数，并添加至环境变量），顾名思义，第一个是为所有用户安装，第二个是为当前用户安装。当然如果你动手能力强，你可以自行配置，参考readme.txt文件即可</h3><img src="/2024/08/14/how-to-hack-JetBrain/scripts.png" class=""><h3 id="4-打开你安装好的JetBrain某款软件，找到激活的界面，选择Activation-code-方式激活"><a href="#4-打开你安装好的JetBrain某款软件，找到激活的界面，选择Activation-code-方式激活" class="headerlink" title="4.打开你安装好的JetBrain某款软件，找到激活的界面，选择Activation code 方式激活"></a>4.打开你安装好的JetBrain某款软件，找到激活的界面，选择Activation code 方式激活</h3><img src="/2024/08/14/how-to-hack-JetBrain/code.png" class=""><h3 id="5-然后回到刚刚的进去的下载jetbra-zip文件的网站，找到你需要的激活的软件，点击星星的位置，复制激活码"><a href="#5-然后回到刚刚的进去的下载jetbra-zip文件的网站，找到你需要的激活的软件，点击星星的位置，复制激活码" class="headerlink" title="5.然后回到刚刚的进去的下载jetbra.zip文件的网站，找到你需要的激活的软件，点击星星的位置，复制激活码"></a>5.然后回到刚刚的进去的下载jetbra.zip文件的网站，找到你需要的激活的软件，点击星星的位置，复制激活码</h3><img src="/2024/08/14/how-to-hack-JetBrain/jetbrain2.png" class=""><h3 id="6-把激活码粘贴到Activation-code的位置，点击activate即可"><a href="#6-把激活码粘贴到Activation-code的位置，点击activate即可" class="headerlink" title="6.把激活码粘贴到Activation code的位置，点击activate即可"></a>6.把激活码粘贴到Activation code的位置，点击activate即可</h3><img src="/2024/08/14/how-to-hack-JetBrain/code2.png" class=""><h3 id="7-然后。你就可以看到熟悉的绿色了，到此使用jetbrains激活码破解激活完成"><a href="#7-然后。你就可以看到熟悉的绿色了，到此使用jetbrains激活码破解激活完成" class="headerlink" title="7.然后。你就可以看到熟悉的绿色了，到此使用jetbrains激活码破解激活完成"></a>7.然后。你就可以看到熟悉的绿色了，到此使用jetbrains激活码破解激活完成</h3>]]></content>
      
      
      <categories>
          
          <category> GPT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i-love-xj</title>
      <link href="/2024/08/14/i-love-xj/"/>
      <url>/2024/08/14/i-love-xj/</url>
      
        <content type="html"><![CDATA[<p>我爱你 小嘉</p><img src="/2024/08/14/i-love-xj/xj.jpg" class="" title="官网">]]></content>
      
      
      <categories>
          
          <category> GPT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何注册chatgpt账号?</title>
      <link href="/2024/03/06/how-to-create-a-account/"/>
      <url>/2024/03/06/how-to-create-a-account/</url>
      
        <content type="html"><![CDATA[<h1 id="1、注册-outlook-邮箱"><a href="#1、注册-outlook-邮箱" class="headerlink" title="1、注册 outlook 邮箱"></a>1、注册 outlook 邮箱</h1><h2 id="1-1-访问-outlook"><a href="#1-1-访问-outlook" class="headerlink" title="1.1 访问 outlook"></a>1.1 访问 outlook</h2><p><a href="https://outlook.com/">https://outlook.com</a></p><p>选择右上角的 登录</p><img src="/2024/03/06/how-to-create-a-account/46.png" class="" title="登录"><h2 id="1-2-立即创建"><a href="#1-2-立即创建" class="headerlink" title="1.2 立即创建"></a>1.2 立即创建</h2><img src="/2024/03/06/how-to-create-a-account/47.png" class="" title="立即创建"><h2 id="1-3-设置邮箱账号"><a href="#1-3-设置邮箱账号" class="headerlink" title="1.3 设置邮箱账号"></a>1.3 设置邮箱账号</h2><img src="/2024/03/06/how-to-create-a-account/48.png" class="" title="设置邮箱账号"><h2 id="1-4-设置个人信息-姓名"><a href="#1-4-设置个人信息-姓名" class="headerlink" title="1.4 设置个人信息-姓名"></a>1.4 设置个人信息-姓名</h2><img src="/2024/03/06/how-to-create-a-account/49.png" class="" title="设置个人信息"><h2 id="1-5-设置个人信息-出生日期，地址"><a href="#1-5-设置个人信息-出生日期，地址" class="headerlink" title="1.5 设置个人信息-出生日期，地址"></a>1.5 设置个人信息-出生日期，地址</h2><p>建议将地址设置为US</p><img src="/2024/03/06/how-to-create-a-account/50.png" class="" title="设置个人信息"><h2 id="1-6-通过真人检验"><a href="#1-6-通过真人检验" class="headerlink" title="1.6 通过真人检验"></a>1.6 通过真人检验</h2><img src="/2024/03/06/how-to-create-a-account/51.png" class="" title="真人验证"><h1 id="2、注册-OpenAI-账号"><a href="#2、注册-OpenAI-账号" class="headerlink" title="2、注册 OpenAI 账号"></a>2、注册 OpenAI 账号</h1><h2 id="2-1-申请-openai"><a href="#2-1-申请-openai" class="headerlink" title="2.1 申请 openai"></a>2.1 申请 openai</h2><p>首先打开 OpenAI 的账户注册页面，输入邮箱:<br><a href="https://chat.openai.com/">https://chat.openai.com/</a></p><img src="/2024/03/06/how-to-create-a-account/52.png" class="" title="选择注册sign up"><h2 id="2-2-输入邮箱"><a href="#2-2-输入邮箱" class="headerlink" title="2.2 输入邮箱"></a>2.2 输入邮箱</h2><p>将刚刚注册的邮箱输入即可</p><img src="/2024/03/06/how-to-create-a-account/53.png" class="" title="输入邮箱"><h2 id="2-3-创建账号"><a href="#2-3-创建账号" class="headerlink" title="2.3 创建账号"></a>2.3 创建账号</h2><p>输入密码</p><img src="/2024/03/06/how-to-create-a-account/54.png" class="" title="输入密码"><h2 id="2-4-等待验证"><a href="#2-4-等待验证" class="headerlink" title="2.4 等待验证"></a>2.4 等待验证</h2><img src="/2024/03/06/how-to-create-a-account/55.png" class="" title="等待验证"><h2 id="2-4-验证邮箱"><a href="#2-4-验证邮箱" class="headerlink" title="2.4 验证邮箱"></a>2.4 验证邮箱</h2><p>验证通过之后，openai会向你的邮箱发送验证邮件</p><img src="/2024/03/06/how-to-create-a-account/56.png" class="" title="邮箱验证"><p>回到刚刚创建的邮箱中检测收件箱</p><img src="/2024/03/06/how-to-create-a-account/57.png" class="" title="收件箱"><p>点击验证即可</p><img src="/2024/03/06/how-to-create-a-account/58.png" class="" title="邮件验证"><h2 id="2-5-输入个人信息"><a href="#2-5-输入个人信息" class="headerlink" title="2.5 输入个人信息"></a>2.5 输入个人信息</h2><p>邮件验证通过之后，需要输入个人信息</p><img src="/2024/03/06/how-to-create-a-account/59.png" class="" title="输入个人信息"><h2 id="2-6-拼图验证"><a href="#2-6-拼图验证" class="headerlink" title="2.6 拼图验证"></a>2.6 拼图验证</h2><p>拼图验证是否是真人</p><img src="/2024/03/06/how-to-create-a-account/60.png" class="" title="拼图验证"><h2 id="2-7-开始聊天"><a href="#2-7-开始聊天" class="headerlink" title="2.7 开始聊天"></a>2.7 开始聊天</h2><p>拼图验证通过，开始使用chatgpt账号</p><img src="/2024/03/06/how-to-create-a-account/61.png" class="" title="开始聊天"><p>ChatGPT 用户获取 GPT-4 的使用权限，是通过购买 GPT Plus 会员，会员的收费标准是 20 美元&#x2F;每月。<br><a href="https://jackma-yj.github.io/2024/02/24/how-to-upgrade-chatgpt4.0/">GPT4-0 充值流程</a><br>购买 GPT Plus 会员后，可以在 Chat 界面选择 GPT4 进行聊天。</p>]]></content>
      
      
      <categories>
          
          <category> GPT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ChatGPT Plus 代充、代升级以及成品号购买</title>
      <link href="/2024/03/04/proxy-charging,%20proxy-upgrading-and-purchase-of-product-numbers/"/>
      <url>/2024/03/04/proxy-charging,%20proxy-upgrading-and-purchase-of-product-numbers/</url>
      
        <content type="html"><![CDATA[<h1 id="ChatGPT-Plus-升级服务介绍"><a href="#ChatGPT-Plus-升级服务介绍" class="headerlink" title="ChatGPT Plus 升级服务介绍"></a>ChatGPT Plus 升级服务介绍</h1><p>商品介绍<br>ChatGPT Plus 产品介绍及权益，ChatGPT Plus 是官方的付费会员服务，升级后可以享受强大的 GPT-4。官方订阅费用为每月 20 美元，订阅者将享有一系列的权益：</p><ul><li>GPT-4 模型：质量比3.5高出数倍！并自带联网，自动切换适合你提示语提问的内容。</li><li>AI 绘画（Dall-E3 模型）：直接向 GPT 提问画画。</li><li>GPT-4V，即上传图片给 GPT 分析解读，结合绘画出图能力，提示生产力。</li><li>语音对话：Voice 聊天功能，需要官方版 ChatGPT APP。</li></ul><h2 id="ChatGPT-Plus成品号与代升级"><a href="#ChatGPT-Plus成品号与代升级" class="headerlink" title="ChatGPT Plus成品号与代升级"></a>ChatGPT Plus成品号与代升级</h2><p>ChatGPT 升级的困难是什么？国人没有海外信用卡，OpenAI 对于信用卡的风控非常严格，对于支付环境都有很高的要求。当你在支付的时候，往往是没法支付成功的。于是本站迎合市场需求，推出了两种服务：<br>1）ChatGPT Plus 成品号出售   2）代充代升级。</p><h3 id="ChatGPT-Plus购买流程"><a href="#ChatGPT-Plus购买流程" class="headerlink" title="ChatGPT Plus购买流程"></a>ChatGPT Plus购买流程</h3><p>ChatGPT Plus成品号购买<br>ChatGPT Plus 成品号 – 无需你注册，拿来登录就用，高效快捷<br>这个商品适合不需要你自己有账号，你想买来就能用的 ChatGPT Plus 账号。 本商品，手工注册，安全有保障。你下单后，我将为你手动注册并充值 – 包售后<br>费用是 199 元，点击查看与购买&gt;，包下号，为你全程交付。后续续费时只需 185 元&#x2F;月，随用随续，按月订阅的。</p><h3 id="ChatGPT-Plus-代充升级"><a href="#ChatGPT-Plus-代充升级" class="headerlink" title="ChatGPT Plus 代充升级"></a>ChatGPT Plus 代充升级</h3><p>ChatGPT Plus 会员的代充、代付、代升级流程如下：<br>1）不需要账号密码，点击左下角的升级，在弹窗里点击升级</p><img src="/2024/03/04/proxy-charging,%20proxy-upgrading-and-purchase-of-product-numbers/2.png" class="" title="复制支付链接"><p>2）如果你能到付款页面，则发送支付页面的网址给我，即可替你完成充值&amp;升级<br>费用是 185 元，点击查看与购买&gt;，包下号，为你全程交付。后续续费时只需 180 元&#x2F;月，随用随续，按月订阅的。</p>]]></content>
      
      
      <categories>
          
          <category> GPT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Onlyfans如何搜索博主?</title>
      <link href="/2024/03/01/how-to-search-for-bloggers-on-onlyfans/"/>
      <url>/2024/03/01/how-to-search-for-bloggers-on-onlyfans/</url>
      
        <content type="html"><![CDATA[<h1 id="1-OnlyFans搜索功能概览"><a href="#1-OnlyFans搜索功能概览" class="headerlink" title="1.OnlyFans搜索功能概览"></a>1.OnlyFans搜索功能概览</h1><p>在OnlyFans上搜索特定博主不像在其他社交媒体平台上那样直观，主要是因为OnlyFans的搜索功能相对有限，并且平台在设计上更注重隐私和独家内容。<br>比如，我们现在想在onlyfans上面看hongkongdoll的视频，如果直接在搜索栏进行搜索，结果如下：</p><img src="/2024/03/01/how-to-search-for-bloggers-on-onlyfans/38.png" class="" title="搜索结果"><p>发现什么内容都没有，是关键词的问题吗？换成hongkong试试呢</p><img src="/2024/03/01/how-to-search-for-bloggers-on-onlyfans/39.png" class="" title="搜索结果"><p>依然还是找不到任何内容,这到底是为什么呢?其实，并不是我们的关键词错了，而是onlyfans为了所谓的用户隐私才故意设置了搜素限制。</p><h1 id="2-如何在Onlyfans上面搜索"><a href="#2-如何在Onlyfans上面搜索" class="headerlink" title="2.如何在Onlyfans上面搜索"></a>2.如何在Onlyfans上面搜索</h1><p>这里主要介绍三种在Onlyfans上面搜索博主的方式，分别是官方服务、社媒跳转和第三方搜索引擎。</p><h2 id="2-1使用Onlyfans官方搜索服务"><a href="#2-1使用Onlyfans官方搜索服务" class="headerlink" title="2.1使用Onlyfans官方搜索服务"></a>2.1使用Onlyfans官方搜索服务</h2><p>我在官网上面找到了如下公告:</p><img src="/2024/03/01/how-to-search-for-bloggers-on-onlyfans/40.png" class="" title="官网公告"><p>根据官网公告，如果你已经关注了某个博主，那么你可以直接用搜索栏搜素到该博主的信息。<br>但是如果你没有关注，那么你只能搜索到博主的帖子内容，而不能搜素到博主的主页。</p><h2 id="2-2通过社交媒体跳转的方式"><a href="#2-2通过社交媒体跳转的方式" class="headerlink" title="2.2通过社交媒体跳转的方式"></a>2.2通过社交媒体跳转的方式</h2><p>如果你在其他平台上面关注了某个博主，例如X，那么这个博主可能会把ta的onlyfans链接放在某个帖子里面，你可以到相应平台去看一看。<br>此外，如果你已经知道某个博主的用户名，那么也可以通过拼接域名的方式来访问，即: onlyfans.com&#x2F;&lt;用户名&gt;，比如hongkongdoll的主页就是onlyfans.com&#x2F;hongkongdoll</p><h2 id="2-3使用第三方搜索工具"><a href="#2-3使用第三方搜索工具" class="headerlink" title="2.3使用第三方搜索工具"></a>2.3使用第三方搜索工具</h2><p>那如果你既没有关注某个博主，也不知道博主的其他社交媒体，该怎么办呢？<br>这里就要向大家介绍今天的重头戏，就是第三方onlyfans搜索引擎。<br><a href="https://onlysearch.co/">https://onlysearch.co</a></p><p>onlysearch就是这么一个平台，它爬取了onlyfans上面所有的用户信息，存放在数据库中。然后你就可以用onlysearch提供的搜索服务，来搜索某个博主并跳转到ta的首页啦~<br>还是拿hongkongdoll举例，我们先进入onlysearch首页，</p><img src="/2024/03/01/how-to-search-for-bloggers-on-onlyfans/41.png" class="" title="搜索框"><p>输入hongkongdoll，然后点击search</p><img src="/2024/03/01/how-to-search-for-bloggers-on-onlyfans/42.png" class="" title="搜索结果"><p>然后就可以搜索到了，点击左下方的open onlyfans，就能跳转到hongkongdoll的onlyfans首页，接下来就能开始愉快的订阅啦~<br><a href="https://jackma-yj.github.io/2024/02/24/how-to-subscribe-to-onlyfans/">国内如何订阅 onlyfans?</a></p>]]></content>
      
      
      <categories>
          
          <category> onlyfans </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何购买midjourney</title>
      <link href="/2024/02/24/how-to-purchase-midjourney/"/>
      <url>/2024/02/24/how-to-purchase-midjourney/</url>
      
        <content type="html"><![CDATA[<ol><li>Midjourney介绍<br>Midjourney 是一款备受欢迎的人工智能生成图像工具，它可以通过输入文字描述，自动生成精美的图像。与许多其他图像生成工具不同，Midjourney 不需要安装任何软件，也不受个人电脑性能的限制，因为它运行在云端服务器上。要使用 Midjourney，只需拥有一个 Discord 帐号并加入相应的 Discord 频道即可。</li><li>midjourney多少钱一个月<br>下面是我为大家总结的midjourney的不同订阅计划的费用和区别<img src="/2024/02/24/how-to-purchase-midjourney/18.png" class="" title="图片引用方法一"></li></ol><p>对于一般用户而言，选择基础计划或者标准计划就可以满足日常使用需求。</p><p>对于商业用途而言，建议选择专业计划或者大型计划。</p><p>3.1 如何使用虚拟卡来订阅midjourney</p><ol><li>首先，去<a href="https://bewildcard.com/i/CHATGPTYJM">wildcard</a>上面购买一张虚拟信用卡，可以得到一张虚拟信用卡和卡片信息。这一步需要9.99美元的开卡费，开完卡之后这就是你的信用卡了，你可以用支付宝向里面充值金额来支付midjourney的订阅。</li><li>登录你的<a href="https://www.midjourney.com/explore">Midjourney账户</a>，进入订阅中心（如果是在Discord频道里，则是在频道输入框输入&#x2F;subscribe，然后点击一下，再回车）</li><li>选择您需要订阅的会员计划，选择月支付&#x2F;年支付</li><li>进入支付页面，选择银行卡支付</li><li>把你在第一步购买到的虚拟信用卡卡号、有效期、CVV码等信息填写到对应的地方<img src="/2024/02/24/how-to-purchase-midjourney/19.png" class="" title="图片引用方法一"></li><li>填写完信息之后，点击确认订阅就可以啦</li></ol>]]></content>
      
      
      <categories>
          
          <category> midjourney </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国内如何订阅onlyfans?</title>
      <link href="/2024/02/24/how-to-subscribe-to-onlyfans/"/>
      <url>/2024/02/24/how-to-subscribe-to-onlyfans/</url>
      
        <content type="html"><![CDATA[<p>什么是onlyfans?<br>OnlyFans是一种内容订阅服务，成立于2016年，允许内容创作者从用户那里获得资金，用户需要支付订阅费用才能查看他们的内容。它在多个领域受到欢迎，包括音乐、健身、摄影，以及成人内容创作。</p><p>注册OnlyFans账户<br>访问OnlyFans官网。<br>创建账户，填写必要的个人信息。<br>邮箱验证及账户激活。</p><p>订阅onlyfans<br>在onlyfans中搜索你想要喜欢并想要订阅的内容，for example Hong Kong doll</p><p>选择订阅时间</p><img src="/2024/02/24/how-to-subscribe-to-onlyfans/5.png" class="" title="图片引用方法一"><p>开通虚拟卡<br>什么是虚拟信用卡<br>简单的说来，就是如果你需要订阅国外的服务（如chatgpt或者onlyfans）的话，就必须要有国外的信用卡。但是国内不是没有办法开通国外信用卡吗，所以就需要使用虚拟信用卡，然后用这张虚拟卡去订阅服务。</p><p>这里我比较推荐虚拟卡平台<a href="https://bewildcard.com/i/CHATGPTYJM">wildcard</a></p><p>如何开通虚拟卡<br>开通步骤如下：</p><p>首先点击链接进入WildCard 一分钟开卡，轻松订阅海外软件服务</p><p>进入网站首页，填写相关信息开卡，中途需要用到支付宝认证，但是只需要扫码即可，不需要上传身份证或者人脸识别。</p><p>支付宝认证完之后，选择卡片开通的时长（根据个人需要选择，个人推荐两年的，比较划算，每天不到两毛钱）。</p><img src="/2024/02/24/how-to-subscribe-to-onlyfans/6.png" class="" title="图片引用方法一"><p>支付之后需要几分钟的时间等待开通成功。开通成功之后就可以拿到一张虚拟卡。</p><p>然后在订阅的链接里面，把下面卡片的信息复制粘贴进去就行了。</p><img src="/2024/02/24/how-to-subscribe-to-onlyfans/7.png" class="" title="图片引用方法一"><p>使用虚拟卡订阅<br>接下来详细看如何用购买的虚拟卡订阅onlyfans。</p><p>回到onlyfans，在点击订阅时长之后，提示添加信用卡</p><img src="/2024/02/24/how-to-subscribe-to-onlyfans/8.png" class="" title="图片引用方法一"><p>然后点击添加信用卡</p><img src="/2024/02/24/how-to-subscribe-to-onlyfans/9.png" class="" title="图片引用方法一"><p>上面需要的每一项信息，都可以直接在虚拟卡网页上看到，直接像下面这样复制过去即可：</p><img src="/2024/02/24/how-to-subscribe-to-onlyfans/10.png" class="" title="图片引用方法一"><p>支付成功之后，便可以放心去体验！</p>]]></content>
      
      
      <categories>
          
          <category> onlyfans </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wildcard使用教程</title>
      <link href="/2024/02/24/wildcard-tutorial/"/>
      <url>/2024/02/24/wildcard-tutorial/</url>
      
        <content type="html"><![CDATA[<ol><li>什么是虚拟信用卡<br>WildCard 虚拟信用卡提供快速、安全的在线支付解决方案，支持通过云闪付充值，不收取消费和提现手续费，特设美国网络环境和英国手机号服务，以及直接客服支持，适合全球业务需求。</li></ol><p>简单的说来，就是如果你订阅国外的服务（如chatgpt或者onlyfans）的话，需要用到国外的信用卡。而wildcard就可以给你提供一个国外的虚拟信用卡，让你可以去订阅相关服务。</p><ol start="2"><li>如何开通虚拟卡<br>开通步骤如下：</li></ol><p>首先点击链接进入 WildCard<a href="https://bewildcard.com/i/CHATGPTYJM">wildcard</a> 一分钟开卡，轻松订阅海外软件服务</p><p>进入网站首页之后，点击立即体验</p><img src="/2024/02/24/wildcard-tutorial/11.png" class="" title="官网"><p>然后点击“立即开卡”</p><img src="/2024/02/24/wildcard-tutorial/12.png" class="" title="立即开卡"><p>然后输入你的手机号码接收验证码（使用邀请码CHATYJM可以在开卡时优惠2美元）</p><img src="/2024/02/24/wildcard-tutorial/13.png" class="" title="图片引用方法一"><p>然后填写你的个人信息</p><img src="/2024/02/24/wildcard-tutorial/14.png" class="" title="图片引用方法一"><p>点击下一步，进行支付宝扫码认证（不需要人脸或身份证）</p><img src="/2024/02/24/wildcard-tutorial/15.png" class="" title="图片引用方法一"><p>支付宝认证完之后，选择卡片开通的时长（根据个人需要选择，个人推荐两年的，比较划算）。此外，如果你是从上面的链接进入，可以得到2美金优惠</p><img src="/2024/02/24/wildcard-tutorial/16.png" class="" title="图片引用方法一"><p>支付之后需要几分钟的时间等待开通成功。</p><p>开通成功之后就可以使用虚拟信用卡来订阅服务啦，直接在订阅的地方，把下面卡片的信息复制粘贴进去就行了。</p><img src="/2024/02/24/wildcard-tutorial/17.png" class="" title="图片引用方法一"><p>总结<br>开卡网站：WildCard 一分钟开卡，轻松订阅海外软件服务</p>]]></content>
      
      
      <categories>
          
          <category> wildcard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPT4-0充值流程</title>
      <link href="/2024/02/24/how-to-upgrade-chatgpt4.0/"/>
      <url>/2024/02/24/how-to-upgrade-chatgpt4.0/</url>
      
        <content type="html"><![CDATA[<p>如果你有 ChatGPT 账号，需要升级4.0，那么这篇文章适合你继续阅读！现在要有效开通的方式有两种：<br>1，网页版通过信用卡订阅<br>2，ChatGPT App礼品卡订阅<br>以下是两种开通方法的喂饭级教程：<br>【网页版充值】<br>充值前请先确认以下三点：<br>1，ChatGPT账户正常登陆。<br>2，充值过程中始终保持美区环境，且开启全局模式。<br>3，使用Chrome浏览器无痕浏览打开openAI。<br>进入Openai官网网址：<a href="https://chat.openai.com/">https://chat.openai.com</a><br>第一步：点击左下角Upgrade to Plus</p><img src="/2024/02/24/how-to-upgrade-chatgpt4.0/1.png" class="" title="图片引用方法一"><p>第二步，复制支付页面的URL</p><img src="/2024/02/24/how-to-upgrade-chatgpt4.0/2.png" class="" title="图片引用方法一"><p><a href="https://bewildcard.com/i/CHATGPTYJM">WildCard | 一分钟开卡，轻松订阅海外软件服务</a></p><p>这家国内的公司应该是专门解决这个问题的，会使用支付宝进行实名认证，大家不用担心，这个是因为走银联通道购汇需要，不用担心安全问题（开户需要填写个人真实信息）</p><p>第二步：获取信用卡<br>（这一步最重要） 因为目前Open AI不支持国内卡，目前比较流行且有效的获取支持订阅的卡的方式–国外信用卡<br>开的卡是有效期2年的虚拟信用卡，开卡费包含两年年费，算下来100元RMB，一天2 毛钱不到，其它费用无，后续自己订阅产品，用多少充多少。<br>开卡之后进入主页面，点击一键升级chatgpt</p><img src="/2024/02/24/how-to-upgrade-chatgpt4.0/3.png" class="" title="图片引用方法一"><p>点击我的邮箱账号符合要求</p><img src="/2024/02/24/how-to-upgrade-chatgpt4.0/36.png" class="" title="图片引用方法一"><p>根据自己的需求选择个人或者团队，点击下一步</p><img src="/2024/02/24/how-to-upgrade-chatgpt4.0/37.png" class="" title="图片引用方法一"><p>将页面向下划，把刚才复制的URL粘贴到对应的框框中，点击确定支付并升级级</p><img src="/2024/02/24/how-to-upgrade-chatgpt4.0/4.png" class="" title="图片引用方法一"><p>恭喜成功升级chatgpt plus!</p>]]></content>
      
      
      <categories>
          
          <category> GPT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
